{
  "version": 3,
  "sources": ["../../ol/xml.js", "../../ol/format/XMLFeature.js", "../../ol/format/xsd.js", "../../ol/format/KML.js", "dep:ol_format_KML"],
  "sourcesContent": ["/**\r\n * @module ol/xml\r\n */\r\nimport {extend} from './array.js';\r\n\r\n/**\r\n * When using {@link module:ol/xml.makeChildAppender} or\r\n * {@link module:ol/xml.makeSimpleNodeFactory}, the top `objectStack` item needs\r\n * to have this structure.\r\n * @typedef {Object} NodeStackItem\r\n * @property {Element} node Node.\r\n */\r\n\r\n/**\r\n * @typedef {function(Element, Array<*>): void} Parser\r\n */\r\n\r\n/**\r\n * @typedef {function(Element, *, Array<*>): void} Serializer\r\n */\r\n\r\n/**\r\n * @type {string}\r\n */\r\nexport const XML_SCHEMA_INSTANCE_URI =\r\n  'http://www.w3.org/2001/XMLSchema-instance';\r\n\r\n/**\r\n * @param {string} namespaceURI Namespace URI.\r\n * @param {string} qualifiedName Qualified name.\r\n * @return {Element} Node.\r\n */\r\nexport function createElementNS(namespaceURI, qualifiedName) {\r\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\r\n}\r\n\r\n/**\r\n * Recursively grab all text content of child nodes into a single string.\r\n * @param {Node} node Node.\r\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\r\n * breaks.\r\n * @return {string} All text content.\r\n * @api\r\n */\r\nexport function getAllTextContent(node, normalizeWhitespace) {\r\n  return getAllTextContent_(node, normalizeWhitespace, []).join('');\r\n}\r\n\r\n/**\r\n * Recursively grab all text content of child nodes into a single string.\r\n * @param {Node} node Node.\r\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\r\n * breaks.\r\n * @param {Array<string>} accumulator Accumulator.\r\n * @private\r\n * @return {Array<string>} Accumulator.\r\n */\r\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\r\n  if (\r\n    node.nodeType == Node.CDATA_SECTION_NODE ||\r\n    node.nodeType == Node.TEXT_NODE\r\n  ) {\r\n    if (normalizeWhitespace) {\r\n      accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\r\n    } else {\r\n      accumulator.push(node.nodeValue);\r\n    }\r\n  } else {\r\n    let n;\r\n    for (n = node.firstChild; n; n = n.nextSibling) {\r\n      getAllTextContent_(n, normalizeWhitespace, accumulator);\r\n    }\r\n  }\r\n  return accumulator;\r\n}\r\n\r\n/**\r\n * @param {Object} object Object.\r\n * @return {boolean} Is a document.\r\n */\r\nexport function isDocument(object) {\r\n  return 'documentElement' in object;\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {?string} namespaceURI Namespace URI.\r\n * @param {string} name Attribute name.\r\n * @return {string} Value\r\n */\r\nexport function getAttributeNS(node, namespaceURI, name) {\r\n  return node.getAttributeNS(namespaceURI, name) || '';\r\n}\r\n\r\n/**\r\n * Parse an XML string to an XML Document.\r\n * @param {string} xml XML.\r\n * @return {Document} Document.\r\n * @api\r\n */\r\nexport function parse(xml) {\r\n  return new DOMParser().parseFromString(xml, 'application/xml');\r\n}\r\n\r\n/**\r\n * Make an array extender function for extending the array at the top of the\r\n * object stack.\r\n * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.\r\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\r\n * @return {Parser} Parser.\r\n * @template T\r\n */\r\nexport function makeArrayExtender(valueReader, thisArg) {\r\n  return (\r\n    /**\r\n     * @param {Node} node Node.\r\n     * @param {Array<*>} objectStack Object stack.\r\n     */\r\n    function (node, objectStack) {\r\n      const value = valueReader.call(\r\n        thisArg !== undefined ? thisArg : this,\r\n        node,\r\n        objectStack\r\n      );\r\n      if (value !== undefined) {\r\n        const array = /** @type {Array<*>} */ (\r\n          objectStack[objectStack.length - 1]\r\n        );\r\n        extend(array, value);\r\n      }\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Make an array pusher function for pushing to the array at the top of the\r\n * object stack.\r\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\r\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\r\n * @return {Parser} Parser.\r\n * @template T\r\n */\r\nexport function makeArrayPusher(valueReader, thisArg) {\r\n  return (\r\n    /**\r\n     * @param {Element} node Node.\r\n     * @param {Array<*>} objectStack Object stack.\r\n     */\r\n    function (node, objectStack) {\r\n      const value = valueReader.call(\r\n        thisArg !== undefined ? thisArg : this,\r\n        node,\r\n        objectStack\r\n      );\r\n      if (value !== undefined) {\r\n        const array = /** @type {Array<*>} */ (\r\n          objectStack[objectStack.length - 1]\r\n        );\r\n        array.push(value);\r\n      }\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Make an object stack replacer function for replacing the object at the\r\n * top of the stack.\r\n * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.\r\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\r\n * @return {Parser} Parser.\r\n * @template T\r\n */\r\nexport function makeReplacer(valueReader, thisArg) {\r\n  return (\r\n    /**\r\n     * @param {Node} node Node.\r\n     * @param {Array<*>} objectStack Object stack.\r\n     */\r\n    function (node, objectStack) {\r\n      const value = valueReader.call(\r\n        thisArg !== undefined ? thisArg : this,\r\n        node,\r\n        objectStack\r\n      );\r\n      if (value !== undefined) {\r\n        objectStack[objectStack.length - 1] = value;\r\n      }\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Make an object property pusher function for adding a property to the\r\n * object at the top of the stack.\r\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\r\n * @param {string} [property] Property.\r\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\r\n * @return {Parser} Parser.\r\n * @template T\r\n */\r\nexport function makeObjectPropertyPusher(valueReader, property, thisArg) {\r\n  return (\r\n    /**\r\n     * @param {Element} node Node.\r\n     * @param {Array<*>} objectStack Object stack.\r\n     */\r\n    function (node, objectStack) {\r\n      const value = valueReader.call(\r\n        thisArg !== undefined ? thisArg : this,\r\n        node,\r\n        objectStack\r\n      );\r\n      if (value !== undefined) {\r\n        const object = /** @type {!Object} */ (\r\n          objectStack[objectStack.length - 1]\r\n        );\r\n        const name = property !== undefined ? property : node.localName;\r\n        let array;\r\n        if (name in object) {\r\n          array = object[name];\r\n        } else {\r\n          array = [];\r\n          object[name] = array;\r\n        }\r\n        array.push(value);\r\n      }\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Make an object property setter function.\r\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\r\n * @param {string} [property] Property.\r\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\r\n * @return {Parser} Parser.\r\n * @template T\r\n */\r\nexport function makeObjectPropertySetter(valueReader, property, thisArg) {\r\n  return (\r\n    /**\r\n     * @param {Element} node Node.\r\n     * @param {Array<*>} objectStack Object stack.\r\n     */\r\n    function (node, objectStack) {\r\n      const value = valueReader.call(\r\n        thisArg !== undefined ? thisArg : this,\r\n        node,\r\n        objectStack\r\n      );\r\n      if (value !== undefined) {\r\n        const object = /** @type {!Object} */ (\r\n          objectStack[objectStack.length - 1]\r\n        );\r\n        const name = property !== undefined ? property : node.localName;\r\n        object[name] = value;\r\n      }\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Create a serializer that appends nodes written by its `nodeWriter` to its\r\n * designated parent. The parent is the `node` of the\r\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\r\n * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.\r\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\r\n * @return {Serializer} Serializer.\r\n * @template T, V\r\n */\r\nexport function makeChildAppender(nodeWriter, thisArg) {\r\n  return function (node, value, objectStack) {\r\n    nodeWriter.call(\r\n      thisArg !== undefined ? thisArg : this,\r\n      node,\r\n      value,\r\n      objectStack\r\n    );\r\n    const parent = /** @type {NodeStackItem} */ (\r\n      objectStack[objectStack.length - 1]\r\n    );\r\n    const parentNode = parent.node;\r\n    parentNode.appendChild(node);\r\n  };\r\n}\r\n\r\n/**\r\n * Create a serializer that calls the provided `nodeWriter` from\r\n * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the\r\n * `nodeWriter` called with an array of values when the `nodeWriter` was\r\n * designed to serialize a single item. An example would be a LineString\r\n * geometry writer, which could be reused for writing MultiLineString\r\n * geometries.\r\n * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.\r\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\r\n * @return {Serializer} Serializer.\r\n * @template T, V\r\n */\r\nexport function makeArraySerializer(nodeWriter, thisArg) {\r\n  let serializersNS, nodeFactory;\r\n  return function (node, value, objectStack) {\r\n    if (serializersNS === undefined) {\r\n      serializersNS = {};\r\n      const serializers = {};\r\n      serializers[node.localName] = nodeWriter;\r\n      serializersNS[node.namespaceURI] = serializers;\r\n      nodeFactory = makeSimpleNodeFactory(node.localName);\r\n    }\r\n    serialize(serializersNS, nodeFactory, value, objectStack);\r\n  };\r\n}\r\n\r\n/**\r\n * Create a node factory which can use the `keys` passed to\r\n * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,\r\n * or a fixed node name. The namespace of the created nodes can either be fixed,\r\n * or the parent namespace will be used.\r\n * @param {string} [fixedNodeName] Fixed node name which will be used for all\r\n *     created nodes. If not provided, the 3rd argument to the resulting node\r\n *     factory needs to be provided and will be the nodeName.\r\n * @param {string} [fixedNamespaceURI] Fixed namespace URI which will be used for\r\n *     all created nodes. If not provided, the namespace of the parent node will\r\n *     be used.\r\n * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.\r\n */\r\nexport function makeSimpleNodeFactory(fixedNodeName, fixedNamespaceURI) {\r\n  return (\r\n    /**\r\n     * @param {*} value Value.\r\n     * @param {Array<*>} objectStack Object stack.\r\n     * @param {string} [newNodeName] Node name.\r\n     * @return {Node} Node.\r\n     */\r\n    function (value, objectStack, newNodeName) {\r\n      const context = /** @type {NodeStackItem} */ (\r\n        objectStack[objectStack.length - 1]\r\n      );\r\n      const node = context.node;\r\n      let nodeName = fixedNodeName;\r\n      if (nodeName === undefined) {\r\n        nodeName = newNodeName;\r\n      }\r\n\r\n      const namespaceURI =\r\n        fixedNamespaceURI !== undefined ? fixedNamespaceURI : node.namespaceURI;\r\n      return createElementNS(namespaceURI, /** @type {string} */ (nodeName));\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * A node factory that creates a node using the parent's `namespaceURI` and the\r\n * `nodeName` passed by {@link module:ol/xml.serialize} or\r\n * {@link module:ol/xml.pushSerializeAndPop} to the node factory.\r\n * @const\r\n * @type {function(*, Array<*>, string=): (Node|undefined)}\r\n */\r\nexport const OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\r\n\r\n/**\r\n * Create an array of `values` to be used with {@link module:ol/xml.serialize} or\r\n * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as\r\n * `key` argument.\r\n * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can\r\n *     be a subset of the `orderedKeys`.\r\n * @param {Array<string>} orderedKeys Keys in the order of the sequence.\r\n * @return {Array<*>} Values in the order of the sequence. The resulting array\r\n *     has the same length as the `orderedKeys` array. Values that are not\r\n *     present in `object` will be `undefined` in the resulting array.\r\n */\r\nexport function makeSequence(object, orderedKeys) {\r\n  const length = orderedKeys.length;\r\n  const sequence = new Array(length);\r\n  for (let i = 0; i < length; ++i) {\r\n    sequence[i] = object[orderedKeys[i]];\r\n  }\r\n  return sequence;\r\n}\r\n\r\n/**\r\n * Create a namespaced structure, using the same values for each namespace.\r\n * This can be used as a starting point for versioned parsers, when only a few\r\n * values are version specific.\r\n * @param {Array<string>} namespaceURIs Namespace URIs.\r\n * @param {T} structure Structure.\r\n * @param {Object<string, T>} [structureNS] Namespaced structure to add to.\r\n * @return {Object<string, T>} Namespaced structure.\r\n * @template T\r\n */\r\nexport function makeStructureNS(namespaceURIs, structure, structureNS) {\r\n  structureNS = structureNS !== undefined ? structureNS : {};\r\n  let i, ii;\r\n  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\r\n    structureNS[namespaceURIs[i]] = structure;\r\n  }\r\n  return structureNS;\r\n}\r\n\r\n/**\r\n * Parse a node using the parsers and object stack.\r\n * @param {Object<string, Object<string, Parser>>} parsersNS\r\n *     Parsers by namespace.\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @param {*} [thisArg] The object to use as `this`.\r\n */\r\nexport function parseNode(parsersNS, node, objectStack, thisArg) {\r\n  let n;\r\n  for (n = node.firstElementChild; n; n = n.nextElementSibling) {\r\n    const parsers = parsersNS[n.namespaceURI];\r\n    if (parsers !== undefined) {\r\n      const parser = parsers[n.localName];\r\n      if (parser !== undefined) {\r\n        parser.call(thisArg, n, objectStack);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Push an object on top of the stack, parse and return the popped object.\r\n * @param {T} object Object.\r\n * @param {Object<string, Object<string, Parser>>} parsersNS\r\n *     Parsers by namespace.\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @param {*} [thisArg] The object to use as `this`.\r\n * @return {T} Object.\r\n * @template T\r\n */\r\nexport function pushParseAndPop(object, parsersNS, node, objectStack, thisArg) {\r\n  objectStack.push(object);\r\n  parseNode(parsersNS, node, objectStack, thisArg);\r\n  return /** @type {T} */ (objectStack.pop());\r\n}\r\n\r\n/**\r\n * Walk through an array of `values` and call a serializer for each value.\r\n * @param {Object<string, Object<string, Serializer>>} serializersNS\r\n *     Namespaced serializers.\r\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\r\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\r\n *     will be used to choose a node writer from `serializersNS`. This\r\n *     separation allows us to decide what kind of node to create, depending on\r\n *     the value we want to serialize. An example for this would be different\r\n *     geometry writers based on the geometry type.\r\n * @param {Array<*>} values Values to serialize. An example would be an array\r\n *     of {@link module:ol/Feature~Feature} instances.\r\n * @param {Array<*>} objectStack Node stack.\r\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\r\n *     `nodeFactory`. This is used for serializing object literals where the\r\n *     node name relates to the property key. The array length of `keys` has\r\n *     to match the length of `values`. For serializing a sequence, `keys`\r\n *     determines the order of the sequence.\r\n * @param {T} [thisArg] The object to use as `this` for the node factory and\r\n *     serializers.\r\n * @template T\r\n */\r\nexport function serialize(\r\n  serializersNS,\r\n  nodeFactory,\r\n  values,\r\n  objectStack,\r\n  keys,\r\n  thisArg\r\n) {\r\n  const length = (keys !== undefined ? keys : values).length;\r\n  let value, node;\r\n  for (let i = 0; i < length; ++i) {\r\n    value = values[i];\r\n    if (value !== undefined) {\r\n      node = nodeFactory.call(\r\n        thisArg !== undefined ? thisArg : this,\r\n        value,\r\n        objectStack,\r\n        keys !== undefined ? keys[i] : undefined\r\n      );\r\n      if (node !== undefined) {\r\n        serializersNS[node.namespaceURI][node.localName].call(\r\n          thisArg,\r\n          node,\r\n          value,\r\n          objectStack\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {O} object Object.\r\n * @param {Object<string, Object<string, Serializer>>} serializersNS\r\n *     Namespaced serializers.\r\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\r\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\r\n *     will be used to choose a node writer from `serializersNS`. This\r\n *     separation allows us to decide what kind of node to create, depending on\r\n *     the value we want to serialize. An example for this would be different\r\n *     geometry writers based on the geometry type.\r\n * @param {Array<*>} values Values to serialize. An example would be an array\r\n *     of {@link module:ol/Feature~Feature} instances.\r\n * @param {Array<*>} objectStack Node stack.\r\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\r\n *     `nodeFactory`. This is used for serializing object literals where the\r\n *     node name relates to the property key. The array length of `keys` has\r\n *     to match the length of `values`. For serializing a sequence, `keys`\r\n *     determines the order of the sequence.\r\n * @param {T} [thisArg] The object to use as `this` for the node factory and\r\n *     serializers.\r\n * @return {O|undefined} Object.\r\n * @template O, T\r\n */\r\nexport function pushSerializeAndPop(\r\n  object,\r\n  serializersNS,\r\n  nodeFactory,\r\n  values,\r\n  objectStack,\r\n  keys,\r\n  thisArg\r\n) {\r\n  objectStack.push(object);\r\n  serialize(serializersNS, nodeFactory, values, objectStack, keys, thisArg);\r\n  return /** @type {O|undefined} */ (objectStack.pop());\r\n}\r\n\r\nlet xmlSerializer_ = undefined;\r\n\r\n/**\r\n * Register a XMLSerializer. Can be used  to inject a XMLSerializer\r\n * where there is no globally available implementation.\r\n *\r\n * @param {XMLSerializer} xmlSerializer A XMLSerializer.\r\n * @api\r\n */\r\nexport function registerXMLSerializer(xmlSerializer) {\r\n  xmlSerializer_ = xmlSerializer;\r\n}\r\n\r\n/**\r\n * @return {XMLSerializer} The XMLSerializer.\r\n */\r\nexport function getXMLSerializer() {\r\n  if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') {\r\n    xmlSerializer_ = new XMLSerializer();\r\n  }\r\n  return xmlSerializer_;\r\n}\r\n\r\nlet document_ = undefined;\r\n\r\n/**\r\n * Register a Document to use when creating nodes for XML serializations. Can be used\r\n * to inject a Document where there is no globally available implementation.\r\n *\r\n * @param {Document} document A Document.\r\n * @api\r\n */\r\nexport function registerDocument(document) {\r\n  document_ = document;\r\n}\r\n\r\n/**\r\n * Get a document that should be used when creating nodes for XML serializations.\r\n * @return {Document} The document.\r\n */\r\nexport function getDocument() {\r\n  if (document_ === undefined && typeof document !== 'undefined') {\r\n    document_ = document.implementation.createDocument('', '', null);\r\n  }\r\n  return document_;\r\n}\r\n", "/**\r\n * @module ol/format/XMLFeature\r\n */\r\nimport FeatureFormat from '../format/Feature.js';\r\nimport {abstract} from '../util.js';\r\nimport {extend} from '../array.js';\r\nimport {getXMLSerializer, isDocument, parse} from '../xml.js';\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * Base class for XML feature formats.\r\n *\r\n * @abstract\r\n */\r\nclass XMLFeature extends FeatureFormat {\r\n  constructor() {\r\n    super();\r\n\r\n    /**\r\n     * @type {XMLSerializer}\r\n     * @private\r\n     */\r\n    this.xmlSerializer_ = getXMLSerializer();\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"./Feature.js\").Type} Format.\r\n   */\r\n  getType() {\r\n    return 'xml';\r\n  }\r\n\r\n  /**\r\n   * Read a single feature.\r\n   *\r\n   * @param {Document|Element|Object|string} source Source.\r\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\r\n   * @return {import(\"../Feature.js\").default} Feature.\r\n   * @api\r\n   */\r\n  readFeature(source, options) {\r\n    if (!source) {\r\n      return null;\r\n    } else if (typeof source === 'string') {\r\n      const doc = parse(source);\r\n      return this.readFeatureFromDocument(doc, options);\r\n    } else if (isDocument(source)) {\r\n      return this.readFeatureFromDocument(\r\n        /** @type {Document} */ (source),\r\n        options\r\n      );\r\n    } else {\r\n      return this.readFeatureFromNode(/** @type {Element} */ (source), options);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Document} doc Document.\r\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\r\n   * @return {import(\"../Feature.js\").default} Feature.\r\n   */\r\n  readFeatureFromDocument(doc, options) {\r\n    const features = this.readFeaturesFromDocument(doc, options);\r\n    if (features.length > 0) {\r\n      return features[0];\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\r\n   * @return {import(\"../Feature.js\").default} Feature.\r\n   */\r\n  readFeatureFromNode(node, options) {\r\n    return null; // not implemented\r\n  }\r\n\r\n  /**\r\n   * Read all features from a feature collection.\r\n   *\r\n   * @param {Document|Element|Object|string} source Source.\r\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\r\n   * @return {Array<import(\"../Feature.js\").default>} Features.\r\n   * @api\r\n   */\r\n  readFeatures(source, options) {\r\n    if (!source) {\r\n      return [];\r\n    } else if (typeof source === 'string') {\r\n      const doc = parse(source);\r\n      return this.readFeaturesFromDocument(doc, options);\r\n    } else if (isDocument(source)) {\r\n      return this.readFeaturesFromDocument(\r\n        /** @type {Document} */ (source),\r\n        options\r\n      );\r\n    } else {\r\n      return this.readFeaturesFromNode(\r\n        /** @type {Element} */ (source),\r\n        options\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Document} doc Document.\r\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\r\n   * @protected\r\n   * @return {Array<import(\"../Feature.js\").default>} Features.\r\n   */\r\n  readFeaturesFromDocument(doc, options) {\r\n    /** @type {Array<import(\"../Feature.js\").default>} */\r\n    const features = [];\r\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\r\n      if (n.nodeType == Node.ELEMENT_NODE) {\r\n        extend(\r\n          features,\r\n          this.readFeaturesFromNode(/** @type {Element} */ (n), options)\r\n        );\r\n      }\r\n    }\r\n    return features;\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {Element} node Node.\r\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\r\n   * @protected\r\n   * @return {Array<import(\"../Feature.js\").default>} Features.\r\n   */\r\n  readFeaturesFromNode(node, options) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Read a single geometry from a source.\r\n   *\r\n   * @param {Document|Element|Object|string} source Source.\r\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\r\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\r\n   */\r\n  readGeometry(source, options) {\r\n    if (!source) {\r\n      return null;\r\n    } else if (typeof source === 'string') {\r\n      const doc = parse(source);\r\n      return this.readGeometryFromDocument(doc, options);\r\n    } else if (isDocument(source)) {\r\n      return this.readGeometryFromDocument(\r\n        /** @type {Document} */ (source),\r\n        options\r\n      );\r\n    } else {\r\n      return this.readGeometryFromNode(\r\n        /** @type {Element} */ (source),\r\n        options\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Document} doc Document.\r\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\r\n   * @protected\r\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\r\n   */\r\n  readGeometryFromDocument(doc, options) {\r\n    return null; // not implemented\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\r\n   * @protected\r\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\r\n   */\r\n  readGeometryFromNode(node, options) {\r\n    return null; // not implemented\r\n  }\r\n\r\n  /**\r\n   * Read the projection from the source.\r\n   *\r\n   * @param {Document|Element|Object|string} source Source.\r\n   * @return {import(\"../proj/Projection.js\").default} Projection.\r\n   * @api\r\n   */\r\n  readProjection(source) {\r\n    if (!source) {\r\n      return null;\r\n    } else if (typeof source === 'string') {\r\n      const doc = parse(source);\r\n      return this.readProjectionFromDocument(doc);\r\n    } else if (isDocument(source)) {\r\n      return this.readProjectionFromDocument(/** @type {Document} */ (source));\r\n    } else {\r\n      return this.readProjectionFromNode(/** @type {Element} */ (source));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Document} doc Document.\r\n   * @protected\r\n   * @return {import(\"../proj/Projection.js\").default} Projection.\r\n   */\r\n  readProjectionFromDocument(doc) {\r\n    return this.dataProjection;\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @protected\r\n   * @return {import(\"../proj/Projection.js\").default} Projection.\r\n   */\r\n  readProjectionFromNode(node) {\r\n    return this.dataProjection;\r\n  }\r\n\r\n  /**\r\n   * Encode a feature as string.\r\n   *\r\n   * @param {import(\"../Feature.js\").default} feature Feature.\r\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\r\n   * @return {string} Encoded feature.\r\n   */\r\n  writeFeature(feature, options) {\r\n    const node = this.writeFeatureNode(feature, options);\r\n    return this.xmlSerializer_.serializeToString(node);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Feature.js\").default} feature Feature.\r\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\r\n   * @protected\r\n   * @return {Node} Node.\r\n   */\r\n  writeFeatureNode(feature, options) {\r\n    return null; // not implemented\r\n  }\r\n\r\n  /**\r\n   * Encode an array of features as string.\r\n   *\r\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\r\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\r\n   * @return {string} Result.\r\n   * @api\r\n   */\r\n  writeFeatures(features, options) {\r\n    const node = this.writeFeaturesNode(features, options);\r\n    return this.xmlSerializer_.serializeToString(node);\r\n  }\r\n\r\n  /**\r\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\r\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\r\n   * @return {Node} Node.\r\n   */\r\n  writeFeaturesNode(features, options) {\r\n    return null; // not implemented\r\n  }\r\n\r\n  /**\r\n   * Encode a geometry as string.\r\n   *\r\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\r\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\r\n   * @return {string} Encoded geometry.\r\n   */\r\n  writeGeometry(geometry, options) {\r\n    const node = this.writeGeometryNode(geometry, options);\r\n    return this.xmlSerializer_.serializeToString(node);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\r\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\r\n   * @return {Node} Node.\r\n   */\r\n  writeGeometryNode(geometry, options) {\r\n    return null; // not implemented\r\n  }\r\n}\r\n\r\nexport default XMLFeature;\r\n", "/**\r\n * @module ol/format/xsd\r\n */\r\nimport {getAllTextContent, getDocument} from '../xml.js';\r\nimport {padNumber} from '../string.js';\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @return {boolean|undefined} Boolean.\r\n */\r\nexport function readBoolean(node) {\r\n  const s = getAllTextContent(node, false);\r\n  return readBooleanString(s);\r\n}\r\n\r\n/**\r\n * @param {string} string String.\r\n * @return {boolean|undefined} Boolean.\r\n */\r\nexport function readBooleanString(string) {\r\n  const m = /^\\s*(true|1)|(false|0)\\s*$/.exec(string);\r\n  if (m) {\r\n    return m[1] !== undefined || false;\r\n  } else {\r\n    return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @return {number|undefined} DateTime in seconds.\r\n */\r\nexport function readDateTime(node) {\r\n  const s = getAllTextContent(node, false);\r\n  const dateTime = Date.parse(s);\r\n  return isNaN(dateTime) ? undefined : dateTime / 1000;\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @return {number|undefined} Decimal.\r\n */\r\nexport function readDecimal(node) {\r\n  const s = getAllTextContent(node, false);\r\n  return readDecimalString(s);\r\n}\r\n\r\n/**\r\n * @param {string} string String.\r\n * @return {number|undefined} Decimal.\r\n */\r\nexport function readDecimalString(string) {\r\n  // FIXME check spec\r\n  const m = /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)\\s*$/i.exec(string);\r\n  if (m) {\r\n    return parseFloat(m[1]);\r\n  } else {\r\n    return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @return {number|undefined} Non negative integer.\r\n */\r\nexport function readPositiveInteger(node) {\r\n  const s = getAllTextContent(node, false);\r\n  return readNonNegativeIntegerString(s);\r\n}\r\n\r\n/**\r\n * @param {string} string String.\r\n * @return {number|undefined} Non negative integer.\r\n */\r\nexport function readNonNegativeIntegerString(string) {\r\n  const m = /^\\s*(\\d+)\\s*$/.exec(string);\r\n  if (m) {\r\n    return parseInt(m[1], 10);\r\n  } else {\r\n    return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @return {string|undefined} String.\r\n */\r\nexport function readString(node) {\r\n  return getAllTextContent(node, false).trim();\r\n}\r\n\r\n/**\r\n * @param {Node} node Node to append a TextNode with the boolean to.\r\n * @param {boolean} bool Boolean.\r\n */\r\nexport function writeBooleanTextNode(node, bool) {\r\n  writeStringTextNode(node, bool ? '1' : '0');\r\n}\r\n\r\n/**\r\n * @param {Node} node Node to append a CDATA Section with the string to.\r\n * @param {string} string String.\r\n */\r\nexport function writeCDATASection(node, string) {\r\n  node.appendChild(getDocument().createCDATASection(string));\r\n}\r\n\r\n/**\r\n * @param {Node} node Node to append a TextNode with the dateTime to.\r\n * @param {number} dateTime DateTime in seconds.\r\n */\r\nexport function writeDateTimeTextNode(node, dateTime) {\r\n  const date = new Date(dateTime * 1000);\r\n  const string =\r\n    date.getUTCFullYear() +\r\n    '-' +\r\n    padNumber(date.getUTCMonth() + 1, 2) +\r\n    '-' +\r\n    padNumber(date.getUTCDate(), 2) +\r\n    'T' +\r\n    padNumber(date.getUTCHours(), 2) +\r\n    ':' +\r\n    padNumber(date.getUTCMinutes(), 2) +\r\n    ':' +\r\n    padNumber(date.getUTCSeconds(), 2) +\r\n    'Z';\r\n  node.appendChild(getDocument().createTextNode(string));\r\n}\r\n\r\n/**\r\n * @param {Node} node Node to append a TextNode with the decimal to.\r\n * @param {number} decimal Decimal.\r\n */\r\nexport function writeDecimalTextNode(node, decimal) {\r\n  const string = decimal.toPrecision();\r\n  node.appendChild(getDocument().createTextNode(string));\r\n}\r\n\r\n/**\r\n * @param {Node} node Node to append a TextNode with the decimal to.\r\n * @param {number} nonNegativeInteger Non negative integer.\r\n */\r\nexport function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {\r\n  const string = nonNegativeInteger.toString();\r\n  node.appendChild(getDocument().createTextNode(string));\r\n}\r\n\r\n/**\r\n * @param {Node} node Node to append a TextNode with the string to.\r\n * @param {string} string String.\r\n */\r\nexport function writeStringTextNode(node, string) {\r\n  node.appendChild(getDocument().createTextNode(string));\r\n}\r\n", "/**\r\n * @module ol/format/KML\r\n */\r\nimport Feature from '../Feature.js';\r\nimport Fill from '../style/Fill.js';\r\nimport GeometryCollection from '../geom/GeometryCollection.js';\r\nimport Icon from '../style/Icon.js';\r\nimport ImageState from '../ImageState.js';\r\nimport LineString from '../geom/LineString.js';\r\nimport MultiLineString from '../geom/MultiLineString.js';\r\nimport MultiPoint from '../geom/MultiPoint.js';\r\nimport MultiPolygon from '../geom/MultiPolygon.js';\r\nimport Point from '../geom/Point.js';\r\nimport Polygon from '../geom/Polygon.js';\r\nimport Stroke from '../style/Stroke.js';\r\nimport Style from '../style/Style.js';\r\nimport Text from '../style/Text.js';\r\nimport XMLFeature from './XMLFeature.js';\r\nimport {\r\n  OBJECT_PROPERTY_NODE_FACTORY,\r\n  XML_SCHEMA_INSTANCE_URI,\r\n  createElementNS,\r\n  getAllTextContent,\r\n  isDocument,\r\n  makeArrayExtender,\r\n  makeArrayPusher,\r\n  makeChildAppender,\r\n  makeObjectPropertySetter,\r\n  makeReplacer,\r\n  makeSequence,\r\n  makeSimpleNodeFactory,\r\n  makeStructureNS,\r\n  parse,\r\n  parseNode,\r\n  pushParseAndPop,\r\n  pushSerializeAndPop,\r\n} from '../xml.js';\r\nimport {asArray} from '../color.js';\r\nimport {assert} from '../asserts.js';\r\nimport {extend} from '../array.js';\r\nimport {get as getProjection} from '../proj.js';\r\nimport {\r\n  readBoolean,\r\n  readDecimal,\r\n  readString,\r\n  writeBooleanTextNode,\r\n  writeCDATASection,\r\n  writeDecimalTextNode,\r\n  writeStringTextNode,\r\n} from './xsd.js';\r\nimport {toRadians} from '../math.js';\r\nimport {transformGeometryWithOptions} from './Feature.js';\r\n\r\n/**\r\n * @typedef {Object} Vec2\r\n * @property {number} x X coordinate.\r\n * @property {import(\"../style/Icon.js\").IconAnchorUnits} xunits Units of x.\r\n * @property {number} y Y coordinate.\r\n * @property {import(\"../style/Icon.js\").IconAnchorUnits} yunits Units of Y.\r\n * @property {import(\"../style/Icon.js\").IconOrigin} [origin] Origin.\r\n */\r\n\r\n/**\r\n * @typedef {Object} GxTrackObject\r\n * @property {Array<Array<number>>} coordinates Coordinates.\r\n * @property {Array<number>} whens Whens.\r\n */\r\n\r\n/**\r\n * @const\r\n * @type {Array<string>}\r\n */\r\nconst GX_NAMESPACE_URIS = ['http://www.google.com/kml/ext/2.2'];\r\n\r\n/**\r\n * @const\r\n * @type {Array<null|string>}\r\n */\r\nconst NAMESPACE_URIS = [\r\n  null,\r\n  'http://earth.google.com/kml/2.0',\r\n  'http://earth.google.com/kml/2.1',\r\n  'http://earth.google.com/kml/2.2',\r\n  'http://www.opengis.net/kml/2.2',\r\n];\r\n\r\n/**\r\n * @const\r\n * @type {string}\r\n */\r\nconst SCHEMA_LOCATION =\r\n  'http://www.opengis.net/kml/2.2 ' +\r\n  'https://developers.google.com/kml/schema/kml22gx.xsd';\r\n\r\n/**\r\n * @type {Object<string, import(\"../style/Icon.js\").IconAnchorUnits>}\r\n */\r\nconst ICON_ANCHOR_UNITS_MAP = {\r\n  'fraction': 'fraction',\r\n  'pixels': 'pixels',\r\n  'insetPixels': 'pixels',\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst PLACEMARK_PARSERS = makeStructureNS(\r\n  NAMESPACE_URIS,\r\n  {\r\n    'ExtendedData': extendedDataParser,\r\n    'Region': regionParser,\r\n    'MultiGeometry': makeObjectPropertySetter(readMultiGeometry, 'geometry'),\r\n    'LineString': makeObjectPropertySetter(readLineString, 'geometry'),\r\n    'LinearRing': makeObjectPropertySetter(readLinearRing, 'geometry'),\r\n    'Point': makeObjectPropertySetter(readPoint, 'geometry'),\r\n    'Polygon': makeObjectPropertySetter(readPolygon, 'geometry'),\r\n    'Style': makeObjectPropertySetter(readStyle),\r\n    'StyleMap': placemarkStyleMapParser,\r\n    'address': makeObjectPropertySetter(readString),\r\n    'description': makeObjectPropertySetter(readString),\r\n    'name': makeObjectPropertySetter(readString),\r\n    'open': makeObjectPropertySetter(readBoolean),\r\n    'phoneNumber': makeObjectPropertySetter(readString),\r\n    'styleUrl': makeObjectPropertySetter(readStyleURL),\r\n    'visibility': makeObjectPropertySetter(readBoolean),\r\n  },\r\n  makeStructureNS(GX_NAMESPACE_URIS, {\r\n    'MultiTrack': makeObjectPropertySetter(readGxMultiTrack, 'geometry'),\r\n    'Track': makeObjectPropertySetter(readGxTrack, 'geometry'),\r\n  })\r\n);\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst NETWORK_LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'ExtendedData': extendedDataParser,\r\n  'Region': regionParser,\r\n  'Link': linkParser,\r\n  'address': makeObjectPropertySetter(readString),\r\n  'description': makeObjectPropertySetter(readString),\r\n  'name': makeObjectPropertySetter(readString),\r\n  'open': makeObjectPropertySetter(readBoolean),\r\n  'phoneNumber': makeObjectPropertySetter(readString),\r\n  'visibility': makeObjectPropertySetter(readBoolean),\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'href': makeObjectPropertySetter(readURI),\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst REGION_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'LatLonAltBox': latLonAltBoxParser,\r\n  'Lod': lodParser,\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Array<string>>}\r\n */\r\n// @ts-ignore\r\nconst KML_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['Document', 'Placemark']);\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\n// @ts-ignore\r\nconst KML_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'Document': makeChildAppender(writeDocument),\r\n  'Placemark': makeChildAppender(writePlacemark),\r\n});\r\n\r\n/**\r\n * @type {import(\"../color.js\").Color}\r\n */\r\nlet DEFAULT_COLOR;\r\n\r\n/**\r\n * @type {Fill|null}\r\n */\r\nlet DEFAULT_FILL_STYLE = null;\r\n\r\n/**\r\n * Get the default fill style (or null if not yet set).\r\n * @return {Fill|null} The default fill style.\r\n */\r\nexport function getDefaultFillStyle() {\r\n  return DEFAULT_FILL_STYLE;\r\n}\r\n\r\n/**\r\n * @type {import(\"../size.js\").Size}\r\n */\r\nlet DEFAULT_IMAGE_STYLE_ANCHOR;\r\n\r\n/**\r\n * @type {import(\"../style/Icon.js\").IconAnchorUnits}\r\n */\r\nlet DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\r\n\r\n/**\r\n * @type {import(\"../style/Icon.js\").IconAnchorUnits}\r\n */\r\nlet DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\r\n\r\n/**\r\n * @type {import(\"../size.js\").Size}\r\n */\r\nlet DEFAULT_IMAGE_STYLE_SIZE;\r\n\r\n/**\r\n * @type {string}\r\n */\r\nlet DEFAULT_IMAGE_STYLE_SRC;\r\n\r\n/**\r\n * @type {import(\"../style/Image.js\").default|null}\r\n */\r\nlet DEFAULT_IMAGE_STYLE = null;\r\n\r\n/**\r\n * Get the default image style (or null if not yet set).\r\n * @return {import(\"../style/Image.js\").default|null} The default image style.\r\n */\r\nexport function getDefaultImageStyle() {\r\n  return DEFAULT_IMAGE_STYLE;\r\n}\r\n\r\n/**\r\n * @type {string}\r\n */\r\nlet DEFAULT_NO_IMAGE_STYLE;\r\n\r\n/**\r\n * @type {Stroke|null}\r\n */\r\nlet DEFAULT_STROKE_STYLE = null;\r\n\r\n/**\r\n * Get the default stroke style (or null if not yet set).\r\n * @return {Stroke|null} The default stroke style.\r\n */\r\nexport function getDefaultStrokeStyle() {\r\n  return DEFAULT_STROKE_STYLE;\r\n}\r\n\r\n/**\r\n * @type {Stroke}\r\n */\r\nlet DEFAULT_TEXT_STROKE_STYLE;\r\n\r\n/**\r\n * @type {Text|null}\r\n */\r\nlet DEFAULT_TEXT_STYLE = null;\r\n\r\n/**\r\n * Get the default text style (or null if not yet set).\r\n * @return {Text|null} The default text style.\r\n */\r\nexport function getDefaultTextStyle() {\r\n  return DEFAULT_TEXT_STYLE;\r\n}\r\n\r\n/**\r\n * @type {Style|null}\r\n */\r\nlet DEFAULT_STYLE = null;\r\n\r\n/**\r\n * Get the default style (or null if not yet set).\r\n * @return {Style|null} The default style.\r\n */\r\nexport function getDefaultStyle() {\r\n  return DEFAULT_STYLE;\r\n}\r\n\r\n/**\r\n * @type {Array<Style>|null}\r\n */\r\nlet DEFAULT_STYLE_ARRAY = null;\r\n\r\n/**\r\n * Get the default style array (or null if not yet set).\r\n * @return {Array<Style>|null} The default style.\r\n */\r\nexport function getDefaultStyleArray() {\r\n  return DEFAULT_STYLE_ARRAY;\r\n}\r\n\r\n/**\r\n * Function that returns the scale needed to normalize an icon image to 32 pixels.\r\n * @param {import(\"../size.js\").Size} size Image size.\r\n * @return {number} Scale.\r\n */\r\nfunction scaleForSize(size) {\r\n  return 32 / Math.min(size[0], size[1]);\r\n}\r\n\r\nfunction createStyleDefaults() {\r\n  DEFAULT_COLOR = [255, 255, 255, 1];\r\n\r\n  DEFAULT_FILL_STYLE = new Fill({\r\n    color: DEFAULT_COLOR,\r\n  });\r\n\r\n  DEFAULT_IMAGE_STYLE_ANCHOR = [20, 2];\r\n\r\n  DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS = 'pixels';\r\n\r\n  DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS = 'pixels';\r\n\r\n  DEFAULT_IMAGE_STYLE_SIZE = [64, 64];\r\n\r\n  DEFAULT_IMAGE_STYLE_SRC =\r\n    'https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png';\r\n\r\n  DEFAULT_IMAGE_STYLE = new Icon({\r\n    anchor: DEFAULT_IMAGE_STYLE_ANCHOR,\r\n    anchorOrigin: 'bottom-left',\r\n    anchorXUnits: DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS,\r\n    anchorYUnits: DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS,\r\n    crossOrigin: 'anonymous',\r\n    rotation: 0,\r\n    scale: scaleForSize(DEFAULT_IMAGE_STYLE_SIZE),\r\n    size: DEFAULT_IMAGE_STYLE_SIZE,\r\n    src: DEFAULT_IMAGE_STYLE_SRC,\r\n  });\r\n\r\n  DEFAULT_NO_IMAGE_STYLE = 'NO_IMAGE';\r\n\r\n  DEFAULT_STROKE_STYLE = new Stroke({\r\n    color: DEFAULT_COLOR,\r\n    width: 1,\r\n  });\r\n\r\n  DEFAULT_TEXT_STROKE_STYLE = new Stroke({\r\n    color: [51, 51, 51, 1],\r\n    width: 2,\r\n  });\r\n\r\n  DEFAULT_TEXT_STYLE = new Text({\r\n    font: 'bold 16px Helvetica',\r\n    fill: DEFAULT_FILL_STYLE,\r\n    stroke: DEFAULT_TEXT_STROKE_STYLE,\r\n    scale: 0.8,\r\n  });\r\n\r\n  DEFAULT_STYLE = new Style({\r\n    fill: DEFAULT_FILL_STYLE,\r\n    image: DEFAULT_IMAGE_STYLE,\r\n    text: DEFAULT_TEXT_STYLE,\r\n    stroke: DEFAULT_STROKE_STYLE,\r\n    zIndex: 0,\r\n  });\r\n\r\n  DEFAULT_STYLE_ARRAY = [DEFAULT_STYLE];\r\n}\r\n\r\n/**\r\n * @type {HTMLTextAreaElement}\r\n */\r\nlet TEXTAREA;\r\n\r\n/**\r\n * A function that takes a url `{string}` and returns a url `{string}`.\r\n * Might be used to change an icon path or to substitute a\r\n * data url obtained from a KMZ array buffer.\r\n *\r\n * @typedef {function(string):string} IconUrlFunction\r\n * @api\r\n */\r\n\r\n/**\r\n * Function that returns a url unchanged.\r\n * @param {string} href Input url.\r\n * @return {string} Output url.\r\n */\r\nfunction defaultIconUrlFunction(href) {\r\n  return href;\r\n}\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {boolean} [extractStyles=true] Extract styles from the KML.\r\n * @property {boolean} [showPointNames=true] Show names as labels for placemarks which contain points.\r\n * @property {Array<Style>} [defaultStyle] Default style. The\r\n * default default style is the same as Google Earth.\r\n * @property {boolean} [writeStyles=true] Write styles into KML.\r\n * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images. Note that you must provide a\r\n * `crossOrigin` value if you want to access pixel data with the Canvas renderer.\r\n * @property {IconUrlFunction} [iconUrlFunction] Function that takes a url string and returns a url string.\r\n * Might be used to change an icon path or to substitute a data url obtained from a KMZ array buffer.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Feature format for reading and writing data in the KML format.\r\n *\r\n * {@link module:ol/format/KML~KML#readFeature} will read the first feature from\r\n * a KML source.\r\n *\r\n * MultiGeometries are converted into GeometryCollections if they are a mix of\r\n * geometry types, and into MultiPoint/MultiLineString/MultiPolygon if they are\r\n * all of the same type.\r\n *\r\n * @api\r\n */\r\nclass KML extends XMLFeature {\r\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n\r\n    options = options ? options : {};\r\n\r\n    if (!DEFAULT_STYLE_ARRAY) {\r\n      createStyleDefaults();\r\n    }\r\n\r\n    /**\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     */\r\n    this.dataProjection = getProjection('EPSG:4326');\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<Style>}\r\n     */\r\n    this.defaultStyle_ = options.defaultStyle\r\n      ? options.defaultStyle\r\n      : DEFAULT_STYLE_ARRAY;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.extractStyles_ =\r\n      options.extractStyles !== undefined ? options.extractStyles : true;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    this.writeStyles_ =\r\n      options.writeStyles !== undefined ? options.writeStyles : true;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Object<string, (Array<Style>|string)>}\r\n     */\r\n    this.sharedStyles_ = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.showPointNames_ =\r\n      options.showPointNames !== undefined ? options.showPointNames : true;\r\n\r\n    /**\r\n     * @type {null|string}\r\n     */\r\n    this.crossOrigin_ =\r\n      options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';\r\n\r\n    /**\r\n     * @type {IconUrlFunction}\r\n     */\r\n    this.iconUrlFunction_ = options.iconUrlFunction\r\n      ? options.iconUrlFunction\r\n      : defaultIconUrlFunction;\r\n\r\n    this.supportedMediaTypes = ['application/vnd.google-earth.kml+xml'];\r\n  }\r\n\r\n  /**\r\n   * @param {Node} node Node.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   * @private\r\n   * @return {Array<Feature>|undefined} Features.\r\n   */\r\n  readDocumentOrFolder_(node, objectStack) {\r\n    // FIXME use scope somehow\r\n    const parsersNS = makeStructureNS(NAMESPACE_URIS, {\r\n      'Document': makeArrayExtender(this.readDocumentOrFolder_, this),\r\n      'Folder': makeArrayExtender(this.readDocumentOrFolder_, this),\r\n      'Placemark': makeArrayPusher(this.readPlacemark_, this),\r\n      'Style': this.readSharedStyle_.bind(this),\r\n      'StyleMap': this.readSharedStyleMap_.bind(this),\r\n    });\r\n    /** @type {Array<Feature>} */\r\n    // @ts-ignore\r\n    const features = pushParseAndPop([], parsersNS, node, objectStack, this);\r\n    if (features) {\r\n      return features;\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   * @private\r\n   * @return {Feature|undefined} Feature.\r\n   */\r\n  readPlacemark_(node, objectStack) {\r\n    const object = pushParseAndPop(\r\n      {'geometry': null},\r\n      PLACEMARK_PARSERS,\r\n      node,\r\n      objectStack,\r\n      this\r\n    );\r\n    if (!object) {\r\n      return undefined;\r\n    }\r\n    const feature = new Feature();\r\n    const id = node.getAttribute('id');\r\n    if (id !== null) {\r\n      feature.setId(id);\r\n    }\r\n    const options = /** @type {import(\"./Feature.js\").ReadOptions} */ (\r\n      objectStack[0]\r\n    );\r\n\r\n    const geometry = object['geometry'];\r\n    if (geometry) {\r\n      transformGeometryWithOptions(geometry, false, options);\r\n    }\r\n    feature.setGeometry(geometry);\r\n    delete object['geometry'];\r\n\r\n    if (this.extractStyles_) {\r\n      const style = object['Style'];\r\n      const styleUrl = object['styleUrl'];\r\n      const styleFunction = createFeatureStyleFunction(\r\n        style,\r\n        styleUrl,\r\n        this.defaultStyle_,\r\n        this.sharedStyles_,\r\n        this.showPointNames_\r\n      );\r\n      feature.setStyle(styleFunction);\r\n    }\r\n    delete object['Style'];\r\n    // we do not remove the styleUrl property from the object, so it\r\n    // gets stored on feature when setProperties is called\r\n\r\n    feature.setProperties(object, true);\r\n\r\n    return feature;\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   * @private\r\n   */\r\n  readSharedStyle_(node, objectStack) {\r\n    const id = node.getAttribute('id');\r\n    if (id !== null) {\r\n      const style = readStyle.call(this, node, objectStack);\r\n      if (style) {\r\n        let styleUri;\r\n        let baseURI = node.baseURI;\r\n        if (!baseURI || baseURI == 'about:blank') {\r\n          baseURI = window.location.href;\r\n        }\r\n        if (baseURI) {\r\n          const url = new URL('#' + id, baseURI);\r\n          styleUri = url.href;\r\n        } else {\r\n          styleUri = '#' + id;\r\n        }\r\n        this.sharedStyles_[styleUri] = style;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   * @private\r\n   */\r\n  readSharedStyleMap_(node, objectStack) {\r\n    const id = node.getAttribute('id');\r\n    if (id === null) {\r\n      return;\r\n    }\r\n    const styleMapValue = readStyleMapValue.call(this, node, objectStack);\r\n    if (!styleMapValue) {\r\n      return;\r\n    }\r\n    let styleUri;\r\n    let baseURI = node.baseURI;\r\n    if (!baseURI || baseURI == 'about:blank') {\r\n      baseURI = window.location.href;\r\n    }\r\n    if (baseURI) {\r\n      const url = new URL('#' + id, baseURI);\r\n      styleUri = url.href;\r\n    } else {\r\n      styleUri = '#' + id;\r\n    }\r\n    this.sharedStyles_[styleUri] = styleMapValue;\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\r\n   * @return {import(\"../Feature.js\").default} Feature.\r\n   */\r\n  readFeatureFromNode(node, options) {\r\n    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {\r\n      return null;\r\n    }\r\n    const feature = this.readPlacemark_(node, [\r\n      this.getReadOptions(node, options),\r\n    ]);\r\n    if (feature) {\r\n      return feature;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {Element} node Node.\r\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\r\n   * @return {Array<import(\"../Feature.js\").default>} Features.\r\n   */\r\n  readFeaturesFromNode(node, options) {\r\n    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {\r\n      return [];\r\n    }\r\n    let features;\r\n    const localName = node.localName;\r\n    if (localName == 'Document' || localName == 'Folder') {\r\n      features = this.readDocumentOrFolder_(node, [\r\n        this.getReadOptions(node, options),\r\n      ]);\r\n      if (features) {\r\n        return features;\r\n      } else {\r\n        return [];\r\n      }\r\n    } else if (localName == 'Placemark') {\r\n      const feature = this.readPlacemark_(node, [\r\n        this.getReadOptions(node, options),\r\n      ]);\r\n      if (feature) {\r\n        return [feature];\r\n      } else {\r\n        return [];\r\n      }\r\n    } else if (localName == 'kml') {\r\n      features = [];\r\n      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\r\n        const fs = this.readFeaturesFromNode(n, options);\r\n        if (fs) {\r\n          extend(features, fs);\r\n        }\r\n      }\r\n      return features;\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the name of the KML.\r\n   *\r\n   * @param {Document|Element|string} source Source.\r\n   * @return {string|undefined} Name.\r\n   * @api\r\n   */\r\n  readName(source) {\r\n    if (!source) {\r\n      return undefined;\r\n    } else if (typeof source === 'string') {\r\n      const doc = parse(source);\r\n      return this.readNameFromDocument(doc);\r\n    } else if (isDocument(source)) {\r\n      return this.readNameFromDocument(/** @type {Document} */ (source));\r\n    } else {\r\n      return this.readNameFromNode(/** @type {Element} */ (source));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Document} doc Document.\r\n   * @return {string|undefined} Name.\r\n   */\r\n  readNameFromDocument(doc) {\r\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\r\n      if (n.nodeType == Node.ELEMENT_NODE) {\r\n        const name = this.readNameFromNode(/** @type {Element} */ (n));\r\n        if (name) {\r\n          return name;\r\n        }\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @return {string|undefined} Name.\r\n   */\r\n  readNameFromNode(node) {\r\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\r\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName == 'name') {\r\n        return readString(n);\r\n      }\r\n    }\r\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\r\n      const localName = n.localName;\r\n      if (\r\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\r\n        (localName == 'Document' ||\r\n          localName == 'Folder' ||\r\n          localName == 'Placemark' ||\r\n          localName == 'kml')\r\n      ) {\r\n        const name = this.readNameFromNode(n);\r\n        if (name) {\r\n          return name;\r\n        }\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Read the network links of the KML.\r\n   *\r\n   * @param {Document|Element|string} source Source.\r\n   * @return {Array<Object>} Network links.\r\n   * @api\r\n   */\r\n  readNetworkLinks(source) {\r\n    const networkLinks = [];\r\n    if (typeof source === 'string') {\r\n      const doc = parse(source);\r\n      extend(networkLinks, this.readNetworkLinksFromDocument(doc));\r\n    } else if (isDocument(source)) {\r\n      extend(\r\n        networkLinks,\r\n        this.readNetworkLinksFromDocument(/** @type {Document} */ (source))\r\n      );\r\n    } else {\r\n      extend(\r\n        networkLinks,\r\n        this.readNetworkLinksFromNode(/** @type {Element} */ (source))\r\n      );\r\n    }\r\n    return networkLinks;\r\n  }\r\n\r\n  /**\r\n   * @param {Document} doc Document.\r\n   * @return {Array<Object>} Network links.\r\n   */\r\n  readNetworkLinksFromDocument(doc) {\r\n    const networkLinks = [];\r\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\r\n      if (n.nodeType == Node.ELEMENT_NODE) {\r\n        extend(\r\n          networkLinks,\r\n          this.readNetworkLinksFromNode(/** @type {Element} */ (n))\r\n        );\r\n      }\r\n    }\r\n    return networkLinks;\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @return {Array<Object>} Network links.\r\n   */\r\n  readNetworkLinksFromNode(node) {\r\n    const networkLinks = [];\r\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\r\n      if (\r\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\r\n        n.localName == 'NetworkLink'\r\n      ) {\r\n        const obj = pushParseAndPop({}, NETWORK_LINK_PARSERS, n, []);\r\n        networkLinks.push(obj);\r\n      }\r\n    }\r\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\r\n      const localName = n.localName;\r\n      if (\r\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\r\n        (localName == 'Document' || localName == 'Folder' || localName == 'kml')\r\n      ) {\r\n        extend(networkLinks, this.readNetworkLinksFromNode(n));\r\n      }\r\n    }\r\n    return networkLinks;\r\n  }\r\n\r\n  /**\r\n   * Read the regions of the KML.\r\n   *\r\n   * @param {Document|Element|string} source Source.\r\n   * @return {Array<Object>} Regions.\r\n   * @api\r\n   */\r\n  readRegion(source) {\r\n    const regions = [];\r\n    if (typeof source === 'string') {\r\n      const doc = parse(source);\r\n      extend(regions, this.readRegionFromDocument(doc));\r\n    } else if (isDocument(source)) {\r\n      extend(\r\n        regions,\r\n        this.readRegionFromDocument(/** @type {Document} */ (source))\r\n      );\r\n    } else {\r\n      extend(regions, this.readRegionFromNode(/** @type {Element} */ (source)));\r\n    }\r\n    return regions;\r\n  }\r\n\r\n  /**\r\n   * @param {Document} doc Document.\r\n   * @return {Array<Object>} Region.\r\n   */\r\n  readRegionFromDocument(doc) {\r\n    const regions = [];\r\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\r\n      if (n.nodeType == Node.ELEMENT_NODE) {\r\n        extend(regions, this.readRegionFromNode(/** @type {Element} */ (n)));\r\n      }\r\n    }\r\n    return regions;\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @return {Array<Object>} Region.\r\n   * @api\r\n   */\r\n  readRegionFromNode(node) {\r\n    const regions = [];\r\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\r\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName == 'Region') {\r\n        const obj = pushParseAndPop({}, REGION_PARSERS, n, []);\r\n        regions.push(obj);\r\n      }\r\n    }\r\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\r\n      const localName = n.localName;\r\n      if (\r\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\r\n        (localName == 'Document' || localName == 'Folder' || localName == 'kml')\r\n      ) {\r\n        extend(regions, this.readRegionFromNode(n));\r\n      }\r\n    }\r\n    return regions;\r\n  }\r\n\r\n  /**\r\n   * Encode an array of features in the KML format as an XML node. GeometryCollections,\r\n   * MultiPoints, MultiLineStrings, and MultiPolygons are output as MultiGeometries.\r\n   *\r\n   * @param {Array<Feature>} features Features.\r\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\r\n   * @return {Node} Node.\r\n   * @api\r\n   */\r\n  writeFeaturesNode(features, options) {\r\n    options = this.adaptOptions(options);\r\n    const kml = createElementNS(NAMESPACE_URIS[4], 'kml');\r\n    const xmlnsUri = 'http://www.w3.org/2000/xmlns/';\r\n    kml.setAttributeNS(xmlnsUri, 'xmlns:gx', GX_NAMESPACE_URIS[0]);\r\n    kml.setAttributeNS(xmlnsUri, 'xmlns:xsi', XML_SCHEMA_INSTANCE_URI);\r\n    kml.setAttributeNS(\r\n      XML_SCHEMA_INSTANCE_URI,\r\n      'xsi:schemaLocation',\r\n      SCHEMA_LOCATION\r\n    );\r\n\r\n    const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {\r\n        node: kml,\r\n      };\r\n    /** @type {!Object<string, (Array<Feature>|Feature|undefined)>} */\r\n    const properties = {};\r\n    if (features.length > 1) {\r\n      properties['Document'] = features;\r\n    } else if (features.length == 1) {\r\n      properties['Placemark'] = features[0];\r\n    }\r\n    const orderedKeys = KML_SEQUENCE[kml.namespaceURI];\r\n    const values = makeSequence(properties, orderedKeys);\r\n    pushSerializeAndPop(\r\n      context,\r\n      KML_SERIALIZERS,\r\n      OBJECT_PROPERTY_NODE_FACTORY,\r\n      values,\r\n      [options],\r\n      orderedKeys,\r\n      this\r\n    );\r\n    return kml;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Style|undefined} foundStyle Style.\r\n * @param {string} name Name.\r\n * @return {Style} style Style.\r\n */\r\nfunction createNameStyleFunction(foundStyle, name) {\r\n  const textOffset = [0, 0];\r\n  /** @type {CanvasTextAlign} */\r\n  let textAlign = 'start';\r\n  const imageStyle = foundStyle.getImage();\r\n  if (imageStyle) {\r\n    const imageSize = imageStyle.getSize();\r\n    if (imageSize && imageSize.length == 2) {\r\n      const imageScale = imageStyle.getScaleArray();\r\n      const anchor = imageStyle.getAnchor();\r\n      // Offset the label to be centered to the right of the icon,\r\n      // if there is one.\r\n      textOffset[0] = imageScale[0] * (imageSize[0] - anchor[0]);\r\n      textOffset[1] = imageScale[1] * (imageSize[1] / 2 - anchor[1]);\r\n      textAlign = 'left';\r\n    }\r\n  }\r\n  let textStyle = foundStyle.getText();\r\n  if (textStyle) {\r\n    // clone the text style, customizing it with name, alignments and offset.\r\n    // Note that kml does not support many text options that OpenLayers does (rotation, textBaseline).\r\n    textStyle = textStyle.clone();\r\n    textStyle.setFont(textStyle.getFont() || DEFAULT_TEXT_STYLE.getFont());\r\n    textStyle.setScale(textStyle.getScale() || DEFAULT_TEXT_STYLE.getScale());\r\n    textStyle.setFill(textStyle.getFill() || DEFAULT_TEXT_STYLE.getFill());\r\n    textStyle.setStroke(textStyle.getStroke() || DEFAULT_TEXT_STROKE_STYLE);\r\n  } else {\r\n    textStyle = DEFAULT_TEXT_STYLE.clone();\r\n  }\r\n  textStyle.setText(name);\r\n  textStyle.setOffsetX(textOffset[0]);\r\n  textStyle.setOffsetY(textOffset[1]);\r\n  textStyle.setTextAlign(textAlign);\r\n\r\n  const nameStyle = new Style({\r\n    image: imageStyle,\r\n    text: textStyle,\r\n  });\r\n  return nameStyle;\r\n}\r\n\r\n/**\r\n * @param {Array<Style>|undefined} style Style.\r\n * @param {string} styleUrl Style URL.\r\n * @param {Array<Style>} defaultStyle Default style.\r\n * @param {!Object<string, (Array<Style>|string)>} sharedStyles Shared styles.\r\n * @param {boolean|undefined} showPointNames true to show names for point placemarks.\r\n * @return {import(\"../style/Style.js\").StyleFunction} Feature style function.\r\n */\r\nfunction createFeatureStyleFunction(\r\n  style,\r\n  styleUrl,\r\n  defaultStyle,\r\n  sharedStyles,\r\n  showPointNames\r\n) {\r\n  return (\r\n    /**\r\n     * @param {Feature} feature feature.\r\n     * @param {number} resolution Resolution.\r\n     * @return {Array<Style>|Style} Style.\r\n     */\r\n    function (feature, resolution) {\r\n      let drawName = showPointNames;\r\n      let name = '';\r\n      let multiGeometryPoints = [];\r\n      if (drawName) {\r\n        const geometry = feature.getGeometry();\r\n        if (geometry) {\r\n          if (geometry instanceof GeometryCollection) {\r\n            multiGeometryPoints = geometry\r\n              .getGeometriesArrayRecursive()\r\n              .filter(function (geometry) {\r\n                const type = geometry.getType();\r\n                return type === 'Point' || type === 'MultiPoint';\r\n              });\r\n            drawName = multiGeometryPoints.length > 0;\r\n          } else {\r\n            const type = geometry.getType();\r\n            drawName = type === 'Point' || type === 'MultiPoint';\r\n          }\r\n        }\r\n      }\r\n\r\n      if (drawName) {\r\n        name = /** @type {string} */ (feature.get('name'));\r\n        drawName = drawName && !!name;\r\n        // convert any html character codes\r\n        if (drawName && /&[^&]+;/.test(name)) {\r\n          if (!TEXTAREA) {\r\n            TEXTAREA = document.createElement('textarea');\r\n          }\r\n          TEXTAREA.innerHTML = name;\r\n          name = TEXTAREA.value;\r\n        }\r\n      }\r\n\r\n      let featureStyle = defaultStyle;\r\n      if (style) {\r\n        featureStyle = style;\r\n      } else if (styleUrl) {\r\n        featureStyle = findStyle(styleUrl, defaultStyle, sharedStyles);\r\n      }\r\n      if (drawName) {\r\n        const nameStyle = createNameStyleFunction(featureStyle[0], name);\r\n        if (multiGeometryPoints.length > 0) {\r\n          // in multigeometries restrict the name style to points and create a\r\n          // style without image or text for geometries requiring fill or stroke\r\n          // including any polygon specific style if there is one\r\n          nameStyle.setGeometry(new GeometryCollection(multiGeometryPoints));\r\n          const baseStyle = new Style({\r\n            geometry: featureStyle[0].getGeometry(),\r\n            image: null,\r\n            fill: featureStyle[0].getFill(),\r\n            stroke: featureStyle[0].getStroke(),\r\n            text: null,\r\n          });\r\n          return [nameStyle, baseStyle].concat(featureStyle.slice(1));\r\n        }\r\n        return nameStyle;\r\n      }\r\n      return featureStyle;\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * @param {Array<Style>|string|undefined} styleValue Style value.\r\n * @param {Array<Style>} defaultStyle Default style.\r\n * @param {!Object<string, (Array<Style>|string)>} sharedStyles\r\n * Shared styles.\r\n * @return {Array<Style>} Style.\r\n */\r\nfunction findStyle(styleValue, defaultStyle, sharedStyles) {\r\n  if (Array.isArray(styleValue)) {\r\n    return styleValue;\r\n  } else if (typeof styleValue === 'string') {\r\n    return findStyle(sharedStyles[styleValue], defaultStyle, sharedStyles);\r\n  } else {\r\n    return defaultStyle;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @return {import(\"../color.js\").Color|undefined} Color.\r\n */\r\nfunction readColor(node) {\r\n  const s = getAllTextContent(node, false);\r\n  // The KML specification states that colors should not include a leading `#`\r\n  // but we tolerate them.\r\n  const m = /^\\s*#?\\s*([0-9A-Fa-f]{8})\\s*$/.exec(s);\r\n  if (m) {\r\n    const hexColor = m[1];\r\n    return [\r\n      parseInt(hexColor.substr(6, 2), 16),\r\n      parseInt(hexColor.substr(4, 2), 16),\r\n      parseInt(hexColor.substr(2, 2), 16),\r\n      parseInt(hexColor.substr(0, 2), 16) / 255,\r\n    ];\r\n  } else {\r\n    return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @return {Array<number>|undefined} Flat coordinates.\r\n */\r\nexport function readFlatCoordinates(node) {\r\n  let s = getAllTextContent(node, false);\r\n  const flatCoordinates = [];\r\n  // The KML specification states that coordinate tuples should not include\r\n  // spaces, but we tolerate them.\r\n  s = s.replace(/\\s*,\\s*/g, ',');\r\n  const re =\r\n    /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?),([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)(?:\\s+|,|$)(?:([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)(?:\\s+|$))?\\s*/i;\r\n  let m;\r\n  while ((m = re.exec(s))) {\r\n    const x = parseFloat(m[1]);\r\n    const y = parseFloat(m[2]);\r\n    const z = m[3] ? parseFloat(m[3]) : 0;\r\n    flatCoordinates.push(x, y, z);\r\n    s = s.substr(m[0].length);\r\n  }\r\n  if (s !== '') {\r\n    return undefined;\r\n  }\r\n  return flatCoordinates;\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @return {string} URI.\r\n */\r\nfunction readURI(node) {\r\n  const s = getAllTextContent(node, false).trim();\r\n  let baseURI = node.baseURI;\r\n  if (!baseURI || baseURI == 'about:blank') {\r\n    baseURI = window.location.href;\r\n  }\r\n  if (baseURI) {\r\n    const url = new URL(s, baseURI);\r\n    return url.href;\r\n  } else {\r\n    return s;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @return {string} URI.\r\n */\r\nfunction readStyleURL(node) {\r\n  // KML files in the wild occasionally forget the leading\r\n  // `#` on styleUrlsdefined in the same document.\r\n  const s = getAllTextContent(node, false)\r\n    .trim()\r\n    .replace(/^(?!.*#)/, '#');\r\n  let baseURI = node.baseURI;\r\n  if (!baseURI || baseURI == 'about:blank') {\r\n    baseURI = window.location.href;\r\n  }\r\n  if (baseURI) {\r\n    const url = new URL(s, baseURI);\r\n    return url.href;\r\n  } else {\r\n    return s;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @return {Vec2} Vec2.\r\n */\r\nfunction readVec2(node) {\r\n  const xunits = node.getAttribute('xunits');\r\n  const yunits = node.getAttribute('yunits');\r\n  /** @type {import('../style/Icon.js').IconOrigin} */\r\n  let origin;\r\n  if (xunits !== 'insetPixels') {\r\n    if (yunits !== 'insetPixels') {\r\n      origin = 'bottom-left';\r\n    } else {\r\n      origin = 'top-left';\r\n    }\r\n  } else {\r\n    if (yunits !== 'insetPixels') {\r\n      origin = 'bottom-right';\r\n    } else {\r\n      origin = 'top-right';\r\n    }\r\n  }\r\n  return {\r\n    x: parseFloat(node.getAttribute('x')),\r\n    xunits: ICON_ANCHOR_UNITS_MAP[xunits],\r\n    y: parseFloat(node.getAttribute('y')),\r\n    yunits: ICON_ANCHOR_UNITS_MAP[yunits],\r\n    origin: origin,\r\n  };\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @return {number|undefined} Scale.\r\n */\r\nfunction readScale(node) {\r\n  return readDecimal(node);\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst STYLE_MAP_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'Pair': pairDataParser,\r\n});\r\n\r\n/**\r\n * @this {KML}\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Array<Style>|string|undefined} StyleMap.\r\n */\r\nfunction readStyleMapValue(node, objectStack) {\r\n  return pushParseAndPop(undefined, STYLE_MAP_PARSERS, node, objectStack, this);\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst ICON_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'Icon': makeObjectPropertySetter(readIcon),\r\n  'color': makeObjectPropertySetter(readColor),\r\n  'heading': makeObjectPropertySetter(readDecimal),\r\n  'hotSpot': makeObjectPropertySetter(readVec2),\r\n  'scale': makeObjectPropertySetter(readScale),\r\n});\r\n\r\n/**\r\n * @this {KML}\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction iconStyleParser(node, objectStack) {\r\n  // FIXME refreshMode\r\n  // FIXME refreshInterval\r\n  // FIXME viewRefreshTime\r\n  // FIXME viewBoundScale\r\n  // FIXME viewFormat\r\n  // FIXME httpQuery\r\n  const object = pushParseAndPop({}, ICON_STYLE_PARSERS, node, objectStack);\r\n  if (!object) {\r\n    return;\r\n  }\r\n  const styleObject = /** @type {Object} */ (\r\n    objectStack[objectStack.length - 1]\r\n  );\r\n  const IconObject = 'Icon' in object ? object['Icon'] : {};\r\n  const drawIcon = !('Icon' in object) || Object.keys(IconObject).length > 0;\r\n  let src;\r\n  const href = /** @type {string|undefined} */ (IconObject['href']);\r\n  if (href) {\r\n    src = href;\r\n  } else if (drawIcon) {\r\n    src = DEFAULT_IMAGE_STYLE_SRC;\r\n  }\r\n  let anchor, anchorXUnits, anchorYUnits;\r\n  /** @type {import('../style/Icon.js').IconOrigin|undefined} */\r\n  let anchorOrigin = 'bottom-left';\r\n  const hotSpot = /** @type {Vec2|undefined} */ (object['hotSpot']);\r\n  if (hotSpot) {\r\n    anchor = [hotSpot.x, hotSpot.y];\r\n    anchorXUnits = hotSpot.xunits;\r\n    anchorYUnits = hotSpot.yunits;\r\n    anchorOrigin = hotSpot.origin;\r\n  } else if (/^https?:\\/\\/maps\\.(?:google|gstatic)\\.com\\//.test(src)) {\r\n    // Google hotspots from https://kml4earth.appspot.com/icons.html#notes\r\n    if (src.includes('pushpin')) {\r\n      anchor = DEFAULT_IMAGE_STYLE_ANCHOR;\r\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\r\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\r\n    } else if (src.includes('arrow-reverse')) {\r\n      anchor = [54, 42];\r\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\r\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\r\n    } else if (src.includes('paddle')) {\r\n      anchor = [32, 1];\r\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\r\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\r\n    }\r\n  }\r\n\r\n  let offset;\r\n  const x = /** @type {number|undefined} */ (IconObject['x']);\r\n  const y = /** @type {number|undefined} */ (IconObject['y']);\r\n  if (x !== undefined && y !== undefined) {\r\n    offset = [x, y];\r\n  }\r\n\r\n  let size;\r\n  const w = /** @type {number|undefined} */ (IconObject['w']);\r\n  const h = /** @type {number|undefined} */ (IconObject['h']);\r\n  if (w !== undefined && h !== undefined) {\r\n    size = [w, h];\r\n  }\r\n\r\n  let rotation;\r\n  const heading = /** @type {number} */ (object['heading']);\r\n  if (heading !== undefined) {\r\n    rotation = toRadians(heading);\r\n  }\r\n\r\n  const scale = /** @type {number|undefined} */ (object['scale']);\r\n\r\n  const color = /** @type {Array<number>|undefined} */ (object['color']);\r\n\r\n  if (drawIcon) {\r\n    if (src == DEFAULT_IMAGE_STYLE_SRC) {\r\n      size = DEFAULT_IMAGE_STYLE_SIZE;\r\n    }\r\n\r\n    const imageStyle = new Icon({\r\n      anchor: anchor,\r\n      anchorOrigin: anchorOrigin,\r\n      anchorXUnits: anchorXUnits,\r\n      anchorYUnits: anchorYUnits,\r\n      crossOrigin: this.crossOrigin_,\r\n      offset: offset,\r\n      offsetOrigin: 'bottom-left',\r\n      rotation: rotation,\r\n      scale: scale,\r\n      size: size,\r\n      src: this.iconUrlFunction_(src),\r\n      color: color,\r\n    });\r\n\r\n    const imageScale = imageStyle.getScaleArray()[0];\r\n    const imageSize = imageStyle.getSize();\r\n    if (imageSize === null) {\r\n      const imageState = imageStyle.getImageState();\r\n      if (imageState === ImageState.IDLE || imageState === ImageState.LOADING) {\r\n        const listener = function () {\r\n          const imageState = imageStyle.getImageState();\r\n          if (\r\n            !(\r\n              imageState === ImageState.IDLE ||\r\n              imageState === ImageState.LOADING\r\n            )\r\n          ) {\r\n            const imageSize = imageStyle.getSize();\r\n            if (imageSize && imageSize.length == 2) {\r\n              const resizeScale = scaleForSize(imageSize);\r\n              imageStyle.setScale(imageScale * resizeScale);\r\n            }\r\n            imageStyle.unlistenImageChange(listener);\r\n          }\r\n        };\r\n        imageStyle.listenImageChange(listener);\r\n        if (imageState === ImageState.IDLE) {\r\n          imageStyle.load();\r\n        }\r\n      }\r\n    } else if (imageSize.length == 2) {\r\n      const resizeScale = scaleForSize(imageSize);\r\n      imageStyle.setScale(imageScale * resizeScale);\r\n    }\r\n    styleObject['imageStyle'] = imageStyle;\r\n  } else {\r\n    // handle the case when we explicitly want to draw no icon.\r\n    styleObject['imageStyle'] = DEFAULT_NO_IMAGE_STYLE;\r\n  }\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst LABEL_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'color': makeObjectPropertySetter(readColor),\r\n  'scale': makeObjectPropertySetter(readScale),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction labelStyleParser(node, objectStack) {\r\n  // FIXME colorMode\r\n  const object = pushParseAndPop({}, LABEL_STYLE_PARSERS, node, objectStack);\r\n  if (!object) {\r\n    return;\r\n  }\r\n  const styleObject = objectStack[objectStack.length - 1];\r\n  const textStyle = new Text({\r\n    fill: new Fill({\r\n      color:\r\n        /** @type {import(\"../color.js\").Color} */\r\n        ('color' in object ? object['color'] : DEFAULT_COLOR),\r\n    }),\r\n    scale: /** @type {number|undefined} */ (object['scale']),\r\n  });\r\n  styleObject['textStyle'] = textStyle;\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst LINE_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'color': makeObjectPropertySetter(readColor),\r\n  'width': makeObjectPropertySetter(readDecimal),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction lineStyleParser(node, objectStack) {\r\n  // FIXME colorMode\r\n  // FIXME gx:outerColor\r\n  // FIXME gx:outerWidth\r\n  // FIXME gx:physicalWidth\r\n  // FIXME gx:labelVisibility\r\n  const object = pushParseAndPop({}, LINE_STYLE_PARSERS, node, objectStack);\r\n  if (!object) {\r\n    return;\r\n  }\r\n  const styleObject = objectStack[objectStack.length - 1];\r\n  const strokeStyle = new Stroke({\r\n    color:\r\n      /** @type {import(\"../color.js\").Color} */\r\n      ('color' in object ? object['color'] : DEFAULT_COLOR),\r\n    width: /** @type {number} */ ('width' in object ? object['width'] : 1),\r\n  });\r\n  styleObject['strokeStyle'] = strokeStyle;\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst POLY_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'color': makeObjectPropertySetter(readColor),\r\n  'fill': makeObjectPropertySetter(readBoolean),\r\n  'outline': makeObjectPropertySetter(readBoolean),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction polyStyleParser(node, objectStack) {\r\n  // FIXME colorMode\r\n  const object = pushParseAndPop({}, POLY_STYLE_PARSERS, node, objectStack);\r\n  if (!object) {\r\n    return;\r\n  }\r\n  const styleObject = objectStack[objectStack.length - 1];\r\n  const fillStyle = new Fill({\r\n    color:\r\n      /** @type {import(\"../color.js\").Color} */\r\n      ('color' in object ? object['color'] : DEFAULT_COLOR),\r\n  });\r\n  styleObject['fillStyle'] = fillStyle;\r\n  const fill = /** @type {boolean|undefined} */ (object['fill']);\r\n  if (fill !== undefined) {\r\n    styleObject['fill'] = fill;\r\n  }\r\n  const outline = /** @type {boolean|undefined} */ (object['outline']);\r\n  if (outline !== undefined) {\r\n    styleObject['outline'] = outline;\r\n  }\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst FLAT_LINEAR_RING_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'coordinates': makeReplacer(readFlatCoordinates),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Array<number>} LinearRing flat coordinates.\r\n */\r\nfunction readFlatLinearRing(node, objectStack) {\r\n  return pushParseAndPop(null, FLAT_LINEAR_RING_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction gxCoordParser(node, objectStack) {\r\n  const gxTrackObject =\r\n    /** @type {GxTrackObject} */\r\n    (objectStack[objectStack.length - 1]);\r\n  const coordinates = gxTrackObject.coordinates;\r\n  const s = getAllTextContent(node, false);\r\n  const re =\r\n    /^\\s*([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s+([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s+([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s*$/i;\r\n  const m = re.exec(s);\r\n  if (m) {\r\n    const x = parseFloat(m[1]);\r\n    const y = parseFloat(m[2]);\r\n    const z = parseFloat(m[3]);\r\n    coordinates.push([x, y, z]);\r\n  } else {\r\n    coordinates.push([]);\r\n  }\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst GX_MULTITRACK_GEOMETRY_PARSERS = makeStructureNS(GX_NAMESPACE_URIS, {\r\n  'Track': makeArrayPusher(readGxTrack),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {MultiLineString|undefined} MultiLineString.\r\n */\r\nfunction readGxMultiTrack(node, objectStack) {\r\n  const lineStrings = pushParseAndPop(\r\n    [],\r\n    GX_MULTITRACK_GEOMETRY_PARSERS,\r\n    node,\r\n    objectStack\r\n  );\r\n  if (!lineStrings) {\r\n    return undefined;\r\n  }\r\n  return new MultiLineString(lineStrings);\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst GX_TRACK_PARSERS = makeStructureNS(\r\n  NAMESPACE_URIS,\r\n  {\r\n    'when': whenParser,\r\n  },\r\n  makeStructureNS(GX_NAMESPACE_URIS, {\r\n    'coord': gxCoordParser,\r\n  })\r\n);\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {LineString|undefined} LineString.\r\n */\r\nfunction readGxTrack(node, objectStack) {\r\n  const gxTrackObject = pushParseAndPop(\r\n    /** @type {GxTrackObject} */ ({\r\n      coordinates: [],\r\n      whens: [],\r\n    }),\r\n    GX_TRACK_PARSERS,\r\n    node,\r\n    objectStack\r\n  );\r\n  if (!gxTrackObject) {\r\n    return undefined;\r\n  }\r\n  const flatCoordinates = [];\r\n  const coordinates = gxTrackObject.coordinates;\r\n  const whens = gxTrackObject.whens;\r\n  for (\r\n    let i = 0, ii = Math.min(coordinates.length, whens.length);\r\n    i < ii;\r\n    ++i\r\n  ) {\r\n    if (coordinates[i].length == 3) {\r\n      flatCoordinates.push(\r\n        coordinates[i][0],\r\n        coordinates[i][1],\r\n        coordinates[i][2],\r\n        whens[i]\r\n      );\r\n    }\r\n  }\r\n  return new LineString(flatCoordinates, 'XYZM');\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst ICON_PARSERS = makeStructureNS(\r\n  NAMESPACE_URIS,\r\n  {\r\n    'href': makeObjectPropertySetter(readURI),\r\n  },\r\n  makeStructureNS(GX_NAMESPACE_URIS, {\r\n    'x': makeObjectPropertySetter(readDecimal),\r\n    'y': makeObjectPropertySetter(readDecimal),\r\n    'w': makeObjectPropertySetter(readDecimal),\r\n    'h': makeObjectPropertySetter(readDecimal),\r\n  })\r\n);\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object} Icon object.\r\n */\r\nfunction readIcon(node, objectStack) {\r\n  const iconObject = pushParseAndPop({}, ICON_PARSERS, node, objectStack);\r\n  if (iconObject) {\r\n    return iconObject;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst GEOMETRY_FLAT_COORDINATES_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'coordinates': makeReplacer(readFlatCoordinates),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Array<number>} Flat coordinates.\r\n */\r\nfunction readFlatCoordinatesFromNode(node, objectStack) {\r\n  return pushParseAndPop(\r\n    null,\r\n    GEOMETRY_FLAT_COORDINATES_PARSERS,\r\n    node,\r\n    objectStack\r\n  );\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst EXTRUDE_AND_ALTITUDE_MODE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'extrude': makeObjectPropertySetter(readBoolean),\r\n  'tessellate': makeObjectPropertySetter(readBoolean),\r\n  'altitudeMode': makeObjectPropertySetter(readString),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {LineString|undefined} LineString.\r\n */\r\nfunction readLineString(node, objectStack) {\r\n  const properties = pushParseAndPop(\r\n    {},\r\n    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,\r\n    node,\r\n    objectStack\r\n  );\r\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\r\n  if (flatCoordinates) {\r\n    const lineString = new LineString(flatCoordinates, 'XYZ');\r\n    lineString.setProperties(properties, true);\r\n    return lineString;\r\n  } else {\r\n    return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Polygon|undefined} Polygon.\r\n */\r\nfunction readLinearRing(node, objectStack) {\r\n  const properties = pushParseAndPop(\r\n    {},\r\n    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,\r\n    node,\r\n    objectStack\r\n  );\r\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\r\n  if (flatCoordinates) {\r\n    const polygon = new Polygon(flatCoordinates, 'XYZ', [\r\n      flatCoordinates.length,\r\n    ]);\r\n    polygon.setProperties(properties, true);\r\n    return polygon;\r\n  } else {\r\n    return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst MULTI_GEOMETRY_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'LineString': makeArrayPusher(readLineString),\r\n  'LinearRing': makeArrayPusher(readLinearRing),\r\n  'MultiGeometry': makeArrayPusher(readMultiGeometry),\r\n  'Point': makeArrayPusher(readPoint),\r\n  'Polygon': makeArrayPusher(readPolygon),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\r\n */\r\nfunction readMultiGeometry(node, objectStack) {\r\n  const geometries = pushParseAndPop(\r\n    [],\r\n    MULTI_GEOMETRY_PARSERS,\r\n    node,\r\n    objectStack\r\n  );\r\n  if (!geometries) {\r\n    return null;\r\n  }\r\n  if (geometries.length === 0) {\r\n    return new GeometryCollection(geometries);\r\n  }\r\n  let multiGeometry;\r\n  let homogeneous = true;\r\n  const type = geometries[0].getType();\r\n  let geometry;\r\n  for (let i = 1, ii = geometries.length; i < ii; ++i) {\r\n    geometry = geometries[i];\r\n    if (geometry.getType() != type) {\r\n      homogeneous = false;\r\n      break;\r\n    }\r\n  }\r\n  if (homogeneous) {\r\n    let layout;\r\n    let flatCoordinates;\r\n    if (type == 'Point') {\r\n      const point = geometries[0];\r\n      layout = point.getLayout();\r\n      flatCoordinates = point.getFlatCoordinates();\r\n      for (let i = 1, ii = geometries.length; i < ii; ++i) {\r\n        geometry = geometries[i];\r\n        extend(flatCoordinates, geometry.getFlatCoordinates());\r\n      }\r\n      multiGeometry = new MultiPoint(flatCoordinates, layout);\r\n      setCommonGeometryProperties(multiGeometry, geometries);\r\n    } else if (type == 'LineString') {\r\n      multiGeometry = new MultiLineString(geometries);\r\n      setCommonGeometryProperties(multiGeometry, geometries);\r\n    } else if (type == 'Polygon') {\r\n      multiGeometry = new MultiPolygon(geometries);\r\n      setCommonGeometryProperties(multiGeometry, geometries);\r\n    } else if (type == 'GeometryCollection') {\r\n      multiGeometry = new GeometryCollection(geometries);\r\n    } else {\r\n      assert(false, 37); // Unknown geometry type found\r\n    }\r\n  } else {\r\n    multiGeometry = new GeometryCollection(geometries);\r\n  }\r\n  return /** @type {import(\"../geom/Geometry.js\").default} */ (multiGeometry);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Point|undefined} Point.\r\n */\r\nfunction readPoint(node, objectStack) {\r\n  const properties = pushParseAndPop(\r\n    {},\r\n    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,\r\n    node,\r\n    objectStack\r\n  );\r\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\r\n  if (flatCoordinates) {\r\n    const point = new Point(flatCoordinates, 'XYZ');\r\n    point.setProperties(properties, true);\r\n    return point;\r\n  } else {\r\n    return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst FLAT_LINEAR_RINGS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'innerBoundaryIs': innerBoundaryIsParser,\r\n  'outerBoundaryIs': outerBoundaryIsParser,\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Polygon|undefined} Polygon.\r\n */\r\nfunction readPolygon(node, objectStack) {\r\n  const properties = pushParseAndPop(\r\n    /** @type {Object<string,*>} */ ({}),\r\n    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,\r\n    node,\r\n    objectStack\r\n  );\r\n  const flatLinearRings = pushParseAndPop(\r\n    [null],\r\n    FLAT_LINEAR_RINGS_PARSERS,\r\n    node,\r\n    objectStack\r\n  );\r\n  if (flatLinearRings && flatLinearRings[0]) {\r\n    const flatCoordinates = flatLinearRings[0];\r\n    const ends = [flatCoordinates.length];\r\n    for (let i = 1, ii = flatLinearRings.length; i < ii; ++i) {\r\n      extend(flatCoordinates, flatLinearRings[i]);\r\n      ends.push(flatCoordinates.length);\r\n    }\r\n    const polygon = new Polygon(flatCoordinates, 'XYZ', ends);\r\n    polygon.setProperties(properties, true);\r\n    return polygon;\r\n  } else {\r\n    return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'IconStyle': iconStyleParser,\r\n  'LabelStyle': labelStyleParser,\r\n  'LineStyle': lineStyleParser,\r\n  'PolyStyle': polyStyleParser,\r\n});\r\n\r\n/**\r\n * @this {KML}\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Array<Style>} Style.\r\n */\r\nfunction readStyle(node, objectStack) {\r\n  const styleObject = pushParseAndPop(\r\n    {},\r\n    STYLE_PARSERS,\r\n    node,\r\n    objectStack,\r\n    this\r\n  );\r\n  if (!styleObject) {\r\n    return null;\r\n  }\r\n  let fillStyle =\r\n    /** @type {Fill} */\r\n    (\r\n      'fillStyle' in styleObject ? styleObject['fillStyle'] : DEFAULT_FILL_STYLE\r\n    );\r\n  const fill = /** @type {boolean|undefined} */ (styleObject['fill']);\r\n  if (fill !== undefined && !fill) {\r\n    fillStyle = null;\r\n  }\r\n  let imageStyle;\r\n  if ('imageStyle' in styleObject) {\r\n    if (styleObject['imageStyle'] != DEFAULT_NO_IMAGE_STYLE) {\r\n      imageStyle = styleObject['imageStyle'];\r\n    }\r\n  } else {\r\n    imageStyle = DEFAULT_IMAGE_STYLE;\r\n  }\r\n  const textStyle =\r\n    /** @type {Text} */\r\n    (\r\n      'textStyle' in styleObject ? styleObject['textStyle'] : DEFAULT_TEXT_STYLE\r\n    );\r\n  const strokeStyle =\r\n    /** @type {Stroke} */\r\n    (\r\n      'strokeStyle' in styleObject\r\n        ? styleObject['strokeStyle']\r\n        : DEFAULT_STROKE_STYLE\r\n    );\r\n  const outline = /** @type {boolean|undefined} */ (styleObject['outline']);\r\n  if (outline !== undefined && !outline) {\r\n    // if the polystyle specifies no outline two styles are needed,\r\n    // one for non-polygon geometries where linestrings require a stroke\r\n    // and one for polygons where there should be no stroke\r\n    return [\r\n      new Style({\r\n        geometry: function (feature) {\r\n          const geometry = feature.getGeometry();\r\n          const type = geometry.getType();\r\n          if (type === 'GeometryCollection') {\r\n            const collection =\r\n              /** @type {import(\"../geom/GeometryCollection\").default} */ (\r\n                geometry\r\n              );\r\n            return new GeometryCollection(\r\n              collection\r\n                .getGeometriesArrayRecursive()\r\n                .filter(function (geometry) {\r\n                  const type = geometry.getType();\r\n                  return type !== 'Polygon' && type !== 'MultiPolygon';\r\n                })\r\n            );\r\n          } else if (type !== 'Polygon' && type !== 'MultiPolygon') {\r\n            return geometry;\r\n          }\r\n        },\r\n        fill: fillStyle,\r\n        image: imageStyle,\r\n        stroke: strokeStyle,\r\n        text: textStyle,\r\n        zIndex: undefined, // FIXME\r\n      }),\r\n      new Style({\r\n        geometry: function (feature) {\r\n          const geometry = feature.getGeometry();\r\n          const type = geometry.getType();\r\n          if (type === 'GeometryCollection') {\r\n            const collection =\r\n              /** @type {import(\"../geom/GeometryCollection\").default} */ (\r\n                geometry\r\n              );\r\n            return new GeometryCollection(\r\n              collection\r\n                .getGeometriesArrayRecursive()\r\n                .filter(function (geometry) {\r\n                  const type = geometry.getType();\r\n                  return type === 'Polygon' || type === 'MultiPolygon';\r\n                })\r\n            );\r\n          } else if (type === 'Polygon' || type === 'MultiPolygon') {\r\n            return geometry;\r\n          }\r\n        },\r\n        fill: fillStyle,\r\n        stroke: null,\r\n        zIndex: undefined, // FIXME\r\n      }),\r\n    ];\r\n  }\r\n  return [\r\n    new Style({\r\n      fill: fillStyle,\r\n      image: imageStyle,\r\n      stroke: strokeStyle,\r\n      text: textStyle,\r\n      zIndex: undefined, // FIXME\r\n    }),\r\n  ];\r\n}\r\n\r\n/**\r\n * Reads an array of geometries and creates arrays for common geometry\r\n * properties. Then sets them to the multi geometry.\r\n * @param {MultiPoint|MultiLineString|MultiPolygon} multiGeometry A multi-geometry.\r\n * @param {Array<import(\"../geom/Geometry.js\").default>} geometries List of geometries.\r\n */\r\nfunction setCommonGeometryProperties(multiGeometry, geometries) {\r\n  const ii = geometries.length;\r\n  const extrudes = new Array(geometries.length);\r\n  const tessellates = new Array(geometries.length);\r\n  const altitudeModes = new Array(geometries.length);\r\n  let hasExtrude, hasTessellate, hasAltitudeMode;\r\n  hasExtrude = false;\r\n  hasTessellate = false;\r\n  hasAltitudeMode = false;\r\n  for (let i = 0; i < ii; ++i) {\r\n    const geometry = geometries[i];\r\n    extrudes[i] = geometry.get('extrude');\r\n    tessellates[i] = geometry.get('tessellate');\r\n    altitudeModes[i] = geometry.get('altitudeMode');\r\n    hasExtrude = hasExtrude || extrudes[i] !== undefined;\r\n    hasTessellate = hasTessellate || tessellates[i] !== undefined;\r\n    hasAltitudeMode = hasAltitudeMode || altitudeModes[i];\r\n  }\r\n  if (hasExtrude) {\r\n    multiGeometry.set('extrude', extrudes);\r\n  }\r\n  if (hasTessellate) {\r\n    multiGeometry.set('tessellate', tessellates);\r\n  }\r\n  if (hasAltitudeMode) {\r\n    multiGeometry.set('altitudeMode', altitudeModes);\r\n  }\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'displayName': makeObjectPropertySetter(readString),\r\n  'value': makeObjectPropertySetter(readString),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction dataParser(node, objectStack) {\r\n  const name = node.getAttribute('name');\r\n  parseNode(DATA_PARSERS, node, objectStack);\r\n  const featureObject = /** @type {Object} */ (\r\n    objectStack[objectStack.length - 1]\r\n  );\r\n  if (name && featureObject.displayName) {\r\n    featureObject[name] = {\r\n      value: featureObject.value,\r\n      displayName: featureObject.displayName,\r\n      toString: function () {\r\n        return featureObject.value;\r\n      },\r\n    };\r\n  } else if (name !== null) {\r\n    featureObject[name] = featureObject.value;\r\n  } else if (featureObject.displayName !== null) {\r\n    featureObject[featureObject.displayName] = featureObject.value;\r\n  }\r\n  delete featureObject['value'];\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst EXTENDED_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'Data': dataParser,\r\n  'SchemaData': schemaDataParser,\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction extendedDataParser(node, objectStack) {\r\n  parseNode(EXTENDED_DATA_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction regionParser(node, objectStack) {\r\n  parseNode(REGION_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst PAIR_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'Style': makeObjectPropertySetter(readStyle),\r\n  'key': makeObjectPropertySetter(readString),\r\n  'styleUrl': makeObjectPropertySetter(readStyleURL),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction pairDataParser(node, objectStack) {\r\n  const pairObject = pushParseAndPop({}, PAIR_PARSERS, node, objectStack, this);\r\n  if (!pairObject) {\r\n    return;\r\n  }\r\n  const key = /** @type {string|undefined} */ (pairObject['key']);\r\n  if (key && key == 'normal') {\r\n    const styleUrl = /** @type {string|undefined} */ (pairObject['styleUrl']);\r\n    if (styleUrl) {\r\n      objectStack[objectStack.length - 1] = styleUrl;\r\n    }\r\n    const style = /** @type {Style} */ (pairObject['Style']);\r\n    if (style) {\r\n      objectStack[objectStack.length - 1] = style;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @this {KML}\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction placemarkStyleMapParser(node, objectStack) {\r\n  const styleMapValue = readStyleMapValue.call(this, node, objectStack);\r\n  if (!styleMapValue) {\r\n    return;\r\n  }\r\n  const placemarkObject = objectStack[objectStack.length - 1];\r\n  if (Array.isArray(styleMapValue)) {\r\n    placemarkObject['Style'] = styleMapValue;\r\n  } else if (typeof styleMapValue === 'string') {\r\n    placemarkObject['styleUrl'] = styleMapValue;\r\n  } else {\r\n    assert(false, 38); // `styleMapValue` has an unknown type\r\n  }\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst SCHEMA_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'SimpleData': simpleDataParser,\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction schemaDataParser(node, objectStack) {\r\n  parseNode(SCHEMA_DATA_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction simpleDataParser(node, objectStack) {\r\n  const name = node.getAttribute('name');\r\n  if (name !== null) {\r\n    const data = readString(node);\r\n    const featureObject = /** @type {Object} */ (\r\n      objectStack[objectStack.length - 1]\r\n    );\r\n    featureObject[name] = data;\r\n  }\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst LAT_LON_ALT_BOX_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'altitudeMode': makeObjectPropertySetter(readString),\r\n  'minAltitude': makeObjectPropertySetter(readDecimal),\r\n  'maxAltitude': makeObjectPropertySetter(readDecimal),\r\n  'north': makeObjectPropertySetter(readDecimal),\r\n  'south': makeObjectPropertySetter(readDecimal),\r\n  'east': makeObjectPropertySetter(readDecimal),\r\n  'west': makeObjectPropertySetter(readDecimal),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction latLonAltBoxParser(node, objectStack) {\r\n  const object = pushParseAndPop(\r\n    {},\r\n    LAT_LON_ALT_BOX_PARSERS,\r\n    node,\r\n    objectStack\r\n  );\r\n  if (!object) {\r\n    return;\r\n  }\r\n  const regionObject = /** @type {Object} */ (\r\n    objectStack[objectStack.length - 1]\r\n  );\r\n  const extent = [\r\n    parseFloat(object['west']),\r\n    parseFloat(object['south']),\r\n    parseFloat(object['east']),\r\n    parseFloat(object['north']),\r\n  ];\r\n  regionObject['extent'] = extent;\r\n  regionObject['altitudeMode'] = object['altitudeMode'];\r\n  regionObject['minAltitude'] = parseFloat(object['minAltitude']);\r\n  regionObject['maxAltitude'] = parseFloat(object['maxAltitude']);\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst LOD_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'minLodPixels': makeObjectPropertySetter(readDecimal),\r\n  'maxLodPixels': makeObjectPropertySetter(readDecimal),\r\n  'minFadeExtent': makeObjectPropertySetter(readDecimal),\r\n  'maxFadeExtent': makeObjectPropertySetter(readDecimal),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction lodParser(node, objectStack) {\r\n  const object = pushParseAndPop({}, LOD_PARSERS, node, objectStack);\r\n  if (!object) {\r\n    return;\r\n  }\r\n  const lodObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);\r\n  lodObject['minLodPixels'] = parseFloat(object['minLodPixels']);\r\n  lodObject['maxLodPixels'] = parseFloat(object['maxLodPixels']);\r\n  lodObject['minFadeExtent'] = parseFloat(object['minFadeExtent']);\r\n  lodObject['maxFadeExtent'] = parseFloat(object['maxFadeExtent']);\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst INNER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  // KML spec only allows one LinearRing  per innerBoundaryIs, but Google Earth\r\n  // allows multiple, so we parse multiple here too.\r\n  'LinearRing': makeArrayPusher(readFlatLinearRing),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction innerBoundaryIsParser(node, objectStack) {\r\n  const innerBoundaryFlatLinearRings = pushParseAndPop(\r\n    /** @type {Array<Array<number>>} */ ([]),\r\n    INNER_BOUNDARY_IS_PARSERS,\r\n    node,\r\n    objectStack\r\n  );\r\n  if (innerBoundaryFlatLinearRings.length > 0) {\r\n    const flatLinearRings =\r\n      /** @type {Array<Array<number>>} */\r\n      (objectStack[objectStack.length - 1]);\r\n    flatLinearRings.push(...innerBoundaryFlatLinearRings);\r\n  }\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst OUTER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'LinearRing': makeReplacer(readFlatLinearRing),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction outerBoundaryIsParser(node, objectStack) {\r\n  /** @type {Array<number>|undefined} */\r\n  const flatLinearRing = pushParseAndPop(\r\n    undefined,\r\n    OUTER_BOUNDARY_IS_PARSERS,\r\n    node,\r\n    objectStack\r\n  );\r\n  if (flatLinearRing) {\r\n    const flatLinearRings =\r\n      /** @type {Array<Array<number>>} */\r\n      (objectStack[objectStack.length - 1]);\r\n    flatLinearRings[0] = flatLinearRing;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction linkParser(node, objectStack) {\r\n  parseNode(LINK_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction whenParser(node, objectStack) {\r\n  const gxTrackObject =\r\n    /** @type {GxTrackObject} */\r\n    (objectStack[objectStack.length - 1]);\r\n  const whens = gxTrackObject.whens;\r\n  const s = getAllTextContent(node, false);\r\n  const when = Date.parse(s);\r\n  whens.push(isNaN(when) ? 0 : when);\r\n}\r\n\r\n/**\r\n * @param {Node} node Node to append a TextNode with the color to.\r\n * @param {import(\"../color.js\").Color|string} color Color.\r\n */\r\nfunction writeColorTextNode(node, color) {\r\n  const rgba = asArray(color);\r\n  const opacity = rgba.length == 4 ? rgba[3] : 1;\r\n  /** @type {Array<string|number>} */\r\n  const abgr = [opacity * 255, rgba[2], rgba[1], rgba[0]];\r\n  for (let i = 0; i < 4; ++i) {\r\n    const hex = Math.floor(/** @type {number} */ (abgr[i])).toString(16);\r\n    abgr[i] = hex.length == 1 ? '0' + hex : hex;\r\n  }\r\n  writeStringTextNode(node, abgr.join(''));\r\n}\r\n\r\n/**\r\n * @param {Node} node Node to append a TextNode with the coordinates to.\r\n * @param {Array<number>} coordinates Coordinates.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction writeCoordinatesTextNode(node, coordinates, objectStack) {\r\n  const context = objectStack[objectStack.length - 1];\r\n\r\n  const layout = context['layout'];\r\n  const stride = context['stride'];\r\n\r\n  let dimension;\r\n  if (layout == 'XY' || layout == 'XYM') {\r\n    dimension = 2;\r\n  } else if (layout == 'XYZ' || layout == 'XYZM') {\r\n    dimension = 3;\r\n  } else {\r\n    assert(false, 34); // Invalid geometry layout\r\n  }\r\n\r\n  const ii = coordinates.length;\r\n  let text = '';\r\n  if (ii > 0) {\r\n    text += coordinates[0];\r\n    for (let d = 1; d < dimension; ++d) {\r\n      text += ',' + coordinates[d];\r\n    }\r\n    for (let i = stride; i < ii; i += stride) {\r\n      text += ' ' + coordinates[i];\r\n      for (let d = 1; d < dimension; ++d) {\r\n        text += ',' + coordinates[i + d];\r\n      }\r\n    }\r\n  }\r\n  writeStringTextNode(node, text);\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\n// @ts-ignore\r\nconst EXTENDEDDATA_NODE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'Data': makeChildAppender(writeDataNode),\r\n  'value': makeChildAppender(writeDataNodeValue),\r\n  'displayName': makeChildAppender(writeDataNodeName),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {{name: *, value: *}} pair Name value pair.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction writeDataNode(node, pair, objectStack) {\r\n  node.setAttribute('name', pair.name);\r\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\r\n  const value = pair.value;\r\n\r\n  if (typeof value == 'object') {\r\n    if (value !== null && value.displayName) {\r\n      pushSerializeAndPop(\r\n        context,\r\n        EXTENDEDDATA_NODE_SERIALIZERS,\r\n        OBJECT_PROPERTY_NODE_FACTORY,\r\n        [value.displayName],\r\n        objectStack,\r\n        ['displayName']\r\n      );\r\n    }\r\n\r\n    if (value !== null && value.value) {\r\n      pushSerializeAndPop(\r\n        context,\r\n        EXTENDEDDATA_NODE_SERIALIZERS,\r\n        OBJECT_PROPERTY_NODE_FACTORY,\r\n        [value.value],\r\n        objectStack,\r\n        ['value']\r\n      );\r\n    }\r\n  } else {\r\n    pushSerializeAndPop(\r\n      context,\r\n      EXTENDEDDATA_NODE_SERIALIZERS,\r\n      OBJECT_PROPERTY_NODE_FACTORY,\r\n      [value],\r\n      objectStack,\r\n      ['value']\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Node} node Node to append a TextNode with the name to.\r\n * @param {string} name DisplayName.\r\n */\r\nfunction writeDataNodeName(node, name) {\r\n  writeCDATASection(node, name);\r\n}\r\n\r\n/**\r\n * @param {Node} node Node to append a CDATA Section with the value to.\r\n * @param {string} value Value.\r\n */\r\nfunction writeDataNodeValue(node, value) {\r\n  writeStringTextNode(node, value);\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\n// @ts-ignore\r\nconst DOCUMENT_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'Placemark': makeChildAppender(writePlacemark),\r\n});\r\n\r\n/**\r\n * @const\r\n * @param {*} value Value.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @param {string} [nodeName] Node name.\r\n * @return {Node|undefined} Node.\r\n */\r\nconst DOCUMENT_NODE_FACTORY = function (value, objectStack, nodeName) {\r\n  const parentNode = objectStack[objectStack.length - 1].node;\r\n  return createElementNS(parentNode.namespaceURI, 'Placemark');\r\n};\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<Feature>} features Features.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @this {KML}\r\n */\r\nfunction writeDocument(node, features, objectStack) {\r\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\r\n  pushSerializeAndPop(\r\n    context,\r\n    DOCUMENT_SERIALIZERS,\r\n    DOCUMENT_NODE_FACTORY,\r\n    features,\r\n    objectStack,\r\n    undefined,\r\n    this\r\n  );\r\n}\r\n\r\n/**\r\n * A factory for creating Data nodes.\r\n * @const\r\n * @type {function(*, Array<*>): (Node|undefined)}\r\n */\r\nconst DATA_NODE_FACTORY = makeSimpleNodeFactory('Data');\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {{names: Array<string>, values: (Array<*>)}} namesAndValues Names and values.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction writeExtendedData(node, namesAndValues, objectStack) {\r\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\r\n  const names = namesAndValues.names;\r\n  const values = namesAndValues.values;\r\n  const length = names.length;\r\n\r\n  for (let i = 0; i < length; i++) {\r\n    pushSerializeAndPop(\r\n      context,\r\n      EXTENDEDDATA_NODE_SERIALIZERS,\r\n      DATA_NODE_FACTORY,\r\n      [{name: names[i], value: values[i]}],\r\n      objectStack\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Array<string>>}\r\n */\r\n// @ts-ignore\r\nconst ICON_SEQUENCE = makeStructureNS(\r\n  NAMESPACE_URIS,\r\n  ['href'],\r\n  makeStructureNS(GX_NAMESPACE_URIS, ['x', 'y', 'w', 'h'])\r\n);\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\n// @ts-ignore\r\nconst ICON_SERIALIZERS = makeStructureNS(\r\n  NAMESPACE_URIS,\r\n  {\r\n    'href': makeChildAppender(writeStringTextNode),\r\n  },\r\n  makeStructureNS(GX_NAMESPACE_URIS, {\r\n    'x': makeChildAppender(writeDecimalTextNode),\r\n    'y': makeChildAppender(writeDecimalTextNode),\r\n    'w': makeChildAppender(writeDecimalTextNode),\r\n    'h': makeChildAppender(writeDecimalTextNode),\r\n  })\r\n);\r\n\r\n/**\r\n * @const\r\n * @param {*} value Value.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @param {string} [nodeName] Node name.\r\n * @return {Node|undefined} Node.\r\n */\r\nconst GX_NODE_FACTORY = function (value, objectStack, nodeName) {\r\n  return createElementNS(GX_NAMESPACE_URIS[0], 'gx:' + nodeName);\r\n};\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Object} icon Icon object.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction writeIcon(node, icon, objectStack) {\r\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\r\n  const parentNode = objectStack[objectStack.length - 1].node;\r\n  let orderedKeys = ICON_SEQUENCE[parentNode.namespaceURI];\r\n  let values = makeSequence(icon, orderedKeys);\r\n  pushSerializeAndPop(\r\n    context,\r\n    ICON_SERIALIZERS,\r\n    OBJECT_PROPERTY_NODE_FACTORY,\r\n    values,\r\n    objectStack,\r\n    orderedKeys\r\n  );\r\n  orderedKeys = ICON_SEQUENCE[GX_NAMESPACE_URIS[0]];\r\n  values = makeSequence(icon, orderedKeys);\r\n  pushSerializeAndPop(\r\n    context,\r\n    ICON_SERIALIZERS,\r\n    GX_NODE_FACTORY,\r\n    values,\r\n    objectStack,\r\n    orderedKeys\r\n  );\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Array<string>>}\r\n */\r\n// @ts-ignore\r\nconst ICON_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\r\n  'scale',\r\n  'heading',\r\n  'Icon',\r\n  'color',\r\n  'hotSpot',\r\n]);\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\n// @ts-ignore\r\nconst ICON_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'Icon': makeChildAppender(writeIcon),\r\n  'color': makeChildAppender(writeColorTextNode),\r\n  'heading': makeChildAppender(writeDecimalTextNode),\r\n  'hotSpot': makeChildAppender(writeVec2),\r\n  'scale': makeChildAppender(writeScaleTextNode),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {import(\"../style/Icon.js\").default} style Icon style.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction writeIconStyle(node, style, objectStack) {\r\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\r\n  const /** @type {Object<string, any>} */ properties = {};\r\n  const src = style.getSrc();\r\n  const size = style.getSize();\r\n  const iconImageSize = style.getImageSize();\r\n  const iconProperties = {\r\n    'href': src,\r\n  };\r\n\r\n  if (size) {\r\n    iconProperties['w'] = size[0];\r\n    iconProperties['h'] = size[1];\r\n    const anchor = style.getAnchor(); // top-left\r\n    const origin = style.getOrigin(); // top-left\r\n\r\n    if (origin && iconImageSize && origin[0] !== 0 && origin[1] !== size[1]) {\r\n      iconProperties['x'] = origin[0];\r\n      iconProperties['y'] = iconImageSize[1] - (origin[1] + size[1]);\r\n    }\r\n\r\n    if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {\r\n      const /** @type {Vec2} */ hotSpot = {\r\n          x: anchor[0],\r\n          xunits: 'pixels',\r\n          y: size[1] - anchor[1],\r\n          yunits: 'pixels',\r\n        };\r\n      properties['hotSpot'] = hotSpot;\r\n    }\r\n  }\r\n\r\n  properties['Icon'] = iconProperties;\r\n\r\n  let scale = style.getScaleArray()[0];\r\n  let imageSize = size;\r\n  if (imageSize === null) {\r\n    imageSize = DEFAULT_IMAGE_STYLE_SIZE;\r\n  }\r\n  if (imageSize.length == 2) {\r\n    const resizeScale = scaleForSize(imageSize);\r\n    scale = scale / resizeScale;\r\n  }\r\n  if (scale !== 1) {\r\n    properties['scale'] = scale;\r\n  }\r\n\r\n  const rotation = style.getRotation();\r\n  if (rotation !== 0) {\r\n    properties['heading'] = rotation; // 0-360\r\n  }\r\n\r\n  const color = style.getColor();\r\n  if (color) {\r\n    properties['color'] = color;\r\n  }\r\n\r\n  const parentNode = objectStack[objectStack.length - 1].node;\r\n  const orderedKeys = ICON_STYLE_SEQUENCE[parentNode.namespaceURI];\r\n  const values = makeSequence(properties, orderedKeys);\r\n  pushSerializeAndPop(\r\n    context,\r\n    ICON_STYLE_SERIALIZERS,\r\n    OBJECT_PROPERTY_NODE_FACTORY,\r\n    values,\r\n    objectStack,\r\n    orderedKeys\r\n  );\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Array<string>>}\r\n */\r\n// @ts-ignore\r\nconst LABEL_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\r\n  'color',\r\n  'scale',\r\n]);\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\n// @ts-ignore\r\nconst LABEL_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'color': makeChildAppender(writeColorTextNode),\r\n  'scale': makeChildAppender(writeScaleTextNode),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Text} style style.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction writeLabelStyle(node, style, objectStack) {\r\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\r\n  const properties = {};\r\n  const fill = style.getFill();\r\n  if (fill) {\r\n    properties['color'] = fill.getColor();\r\n  }\r\n  const scale = style.getScale();\r\n  if (scale && scale !== 1) {\r\n    properties['scale'] = scale;\r\n  }\r\n  const parentNode = objectStack[objectStack.length - 1].node;\r\n  const orderedKeys = LABEL_STYLE_SEQUENCE[parentNode.namespaceURI];\r\n  const values = makeSequence(properties, orderedKeys);\r\n  pushSerializeAndPop(\r\n    context,\r\n    LABEL_STYLE_SERIALIZERS,\r\n    OBJECT_PROPERTY_NODE_FACTORY,\r\n    values,\r\n    objectStack,\r\n    orderedKeys\r\n  );\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Array<string>>}\r\n */\r\n// @ts-ignore\r\nconst LINE_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['color', 'width']);\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\n// @ts-ignore\r\nconst LINE_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'color': makeChildAppender(writeColorTextNode),\r\n  'width': makeChildAppender(writeDecimalTextNode),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Stroke} style style.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction writeLineStyle(node, style, objectStack) {\r\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\r\n  const properties = {\r\n    'color': style.getColor(),\r\n    'width': Number(style.getWidth()) || 1,\r\n  };\r\n  const parentNode = objectStack[objectStack.length - 1].node;\r\n  const orderedKeys = LINE_STYLE_SEQUENCE[parentNode.namespaceURI];\r\n  const values = makeSequence(properties, orderedKeys);\r\n  pushSerializeAndPop(\r\n    context,\r\n    LINE_STYLE_SERIALIZERS,\r\n    OBJECT_PROPERTY_NODE_FACTORY,\r\n    values,\r\n    objectStack,\r\n    orderedKeys\r\n  );\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, string>}\r\n */\r\nconst GEOMETRY_TYPE_TO_NODENAME = {\r\n  'Point': 'Point',\r\n  'LineString': 'LineString',\r\n  'LinearRing': 'LinearRing',\r\n  'Polygon': 'Polygon',\r\n  'MultiPoint': 'MultiGeometry',\r\n  'MultiLineString': 'MultiGeometry',\r\n  'MultiPolygon': 'MultiGeometry',\r\n  'GeometryCollection': 'MultiGeometry',\r\n};\r\n\r\n/**\r\n * @const\r\n * @param {*} value Value.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @param {string} [nodeName] Node name.\r\n * @return {Node|undefined} Node.\r\n */\r\nconst GEOMETRY_NODE_FACTORY = function (value, objectStack, nodeName) {\r\n  if (value) {\r\n    const parentNode = objectStack[objectStack.length - 1].node;\r\n    return createElementNS(\r\n      parentNode.namespaceURI,\r\n      GEOMETRY_TYPE_TO_NODENAME[\r\n        /** @type {import(\"../geom/Geometry.js\").default} */ (value).getType()\r\n      ]\r\n    );\r\n  }\r\n};\r\n\r\n/**\r\n * A factory for creating Point nodes.\r\n * @const\r\n * @type {function(*, Array<*>, string=): (Node|undefined)}\r\n */\r\nconst POINT_NODE_FACTORY = makeSimpleNodeFactory('Point');\r\n\r\n/**\r\n * A factory for creating LineString nodes.\r\n * @const\r\n * @type {function(*, Array<*>, string=): (Node|undefined)}\r\n */\r\nconst LINE_STRING_NODE_FACTORY = makeSimpleNodeFactory('LineString');\r\n\r\n/**\r\n * A factory for creating LinearRing nodes.\r\n * @const\r\n * @type {function(*, Array<*>, string=): (Node|undefined)}\r\n */\r\nconst LINEAR_RING_NODE_FACTORY = makeSimpleNodeFactory('LinearRing');\r\n\r\n/**\r\n * A factory for creating Polygon nodes.\r\n * @const\r\n * @type {function(*, Array<*>, string=): (Node|undefined)}\r\n */\r\nconst POLYGON_NODE_FACTORY = makeSimpleNodeFactory('Polygon');\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\n// @ts-ignore\r\nconst MULTI_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'LineString': makeChildAppender(writePrimitiveGeometry),\r\n  'Point': makeChildAppender(writePrimitiveGeometry),\r\n  'Polygon': makeChildAppender(writePolygon),\r\n  'GeometryCollection': makeChildAppender(writeMultiGeometry),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction writeMultiGeometry(node, geometry, objectStack) {\r\n  /** @type {import(\"../xml.js\").NodeStackItem} */\r\n  const context = {node: node};\r\n  const type = geometry.getType();\r\n  /** @type {Array<import(\"../geom/Geometry.js\").default>} */\r\n  let geometries = [];\r\n  /** @type {function(*, Array<*>, string=): (Node|undefined)} */\r\n  let factory;\r\n  if (type === 'GeometryCollection') {\r\n    /** @type {GeometryCollection} */ (geometry)\r\n      .getGeometriesArrayRecursive()\r\n      .forEach(function (geometry) {\r\n        const type = geometry.getType();\r\n        if (type === 'MultiPoint') {\r\n          geometries = geometries.concat(\r\n            /** @type {MultiPoint} */ (geometry).getPoints()\r\n          );\r\n        } else if (type === 'MultiLineString') {\r\n          geometries = geometries.concat(\r\n            /** @type {MultiLineString} */ (geometry).getLineStrings()\r\n          );\r\n        } else if (type === 'MultiPolygon') {\r\n          geometries = geometries.concat(\r\n            /** @type {MultiPolygon} */ (geometry).getPolygons()\r\n          );\r\n        } else if (\r\n          type === 'Point' ||\r\n          type === 'LineString' ||\r\n          type === 'Polygon'\r\n        ) {\r\n          geometries.push(geometry);\r\n        } else {\r\n          assert(false, 39); // Unknown geometry type\r\n        }\r\n      });\r\n    factory = GEOMETRY_NODE_FACTORY;\r\n  } else if (type === 'MultiPoint') {\r\n    geometries = /** @type {MultiPoint} */ (geometry).getPoints();\r\n    factory = POINT_NODE_FACTORY;\r\n  } else if (type === 'MultiLineString') {\r\n    geometries = /** @type {MultiLineString} */ (geometry).getLineStrings();\r\n    factory = LINE_STRING_NODE_FACTORY;\r\n  } else if (type === 'MultiPolygon') {\r\n    geometries = /** @type {MultiPolygon} */ (geometry).getPolygons();\r\n    factory = POLYGON_NODE_FACTORY;\r\n  } else {\r\n    assert(false, 39); // Unknown geometry type\r\n  }\r\n  pushSerializeAndPop(\r\n    context,\r\n    MULTI_GEOMETRY_SERIALIZERS,\r\n    factory,\r\n    geometries,\r\n    objectStack\r\n  );\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\n// @ts-ignore\r\nconst BOUNDARY_IS_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'LinearRing': makeChildAppender(writePrimitiveGeometry),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {import(\"../geom/LinearRing.js\").default} linearRing Linear ring.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction writeBoundaryIs(node, linearRing, objectStack) {\r\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\r\n  pushSerializeAndPop(\r\n    context,\r\n    BOUNDARY_IS_SERIALIZERS,\r\n    LINEAR_RING_NODE_FACTORY,\r\n    [linearRing],\r\n    objectStack\r\n  );\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\n// @ts-ignore\r\nconst PLACEMARK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'ExtendedData': makeChildAppender(writeExtendedData),\r\n  'MultiGeometry': makeChildAppender(writeMultiGeometry),\r\n  'LineString': makeChildAppender(writePrimitiveGeometry),\r\n  'LinearRing': makeChildAppender(writePrimitiveGeometry),\r\n  'Point': makeChildAppender(writePrimitiveGeometry),\r\n  'Polygon': makeChildAppender(writePolygon),\r\n  'Style': makeChildAppender(writeStyle),\r\n  'address': makeChildAppender(writeStringTextNode),\r\n  'description': makeChildAppender(writeStringTextNode),\r\n  'name': makeChildAppender(writeStringTextNode),\r\n  'open': makeChildAppender(writeBooleanTextNode),\r\n  'phoneNumber': makeChildAppender(writeStringTextNode),\r\n  'styleUrl': makeChildAppender(writeStringTextNode),\r\n  'visibility': makeChildAppender(writeBooleanTextNode),\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Array<string>>}\r\n */\r\n// @ts-ignore\r\nconst PLACEMARK_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\r\n  'name',\r\n  'open',\r\n  'visibility',\r\n  'address',\r\n  'phoneNumber',\r\n  'description',\r\n  'styleUrl',\r\n  'Style',\r\n]);\r\n\r\n/**\r\n * A factory for creating ExtendedData nodes.\r\n * @const\r\n * @type {function(*, Array<*>): (Node|undefined)}\r\n */\r\nconst EXTENDEDDATA_NODE_FACTORY = makeSimpleNodeFactory('ExtendedData');\r\n\r\n/**\r\n * FIXME currently we do serialize arbitrary/custom feature properties\r\n * (ExtendedData).\r\n * @param {Element} node Node.\r\n * @param {Feature} feature Feature.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @this {KML}\r\n */\r\nfunction writePlacemark(node, feature, objectStack) {\r\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\r\n\r\n  // set id\r\n  if (feature.getId()) {\r\n    node.setAttribute('id', /** @type {string} */ (feature.getId()));\r\n  }\r\n\r\n  // serialize properties (properties unknown to KML are not serialized)\r\n  const properties = feature.getProperties();\r\n\r\n  // don't export these to ExtendedData\r\n  const filter = {\r\n    'address': 1,\r\n    'description': 1,\r\n    'name': 1,\r\n    'open': 1,\r\n    'phoneNumber': 1,\r\n    'styleUrl': 1,\r\n    'visibility': 1,\r\n  };\r\n  filter[feature.getGeometryName()] = 1;\r\n  const keys = Object.keys(properties || {})\r\n    .sort()\r\n    .filter(function (v) {\r\n      return !filter[v];\r\n    });\r\n\r\n  const styleFunction = feature.getStyleFunction();\r\n  if (styleFunction) {\r\n    // FIXME the styles returned by the style function are supposed to be\r\n    // resolution-independent here\r\n    const styles = styleFunction(feature, 0);\r\n    if (styles) {\r\n      const styleArray = Array.isArray(styles) ? styles : [styles];\r\n      let pointStyles = styleArray;\r\n      if (feature.getGeometry()) {\r\n        pointStyles = styleArray.filter(function (style) {\r\n          const geometry = style.getGeometryFunction()(feature);\r\n          if (geometry) {\r\n            const type = geometry.getType();\r\n            if (type === 'GeometryCollection') {\r\n              return /** @type {GeometryCollection} */ (geometry)\r\n                .getGeometriesArrayRecursive()\r\n                .filter(function (geometry) {\r\n                  const type = geometry.getType();\r\n                  return type === 'Point' || type === 'MultiPoint';\r\n                }).length;\r\n            }\r\n            return type === 'Point' || type === 'MultiPoint';\r\n          }\r\n        });\r\n        ('Point');\r\n      }\r\n      if (this.writeStyles_) {\r\n        let lineStyles = styleArray;\r\n        let polyStyles = styleArray;\r\n        if (feature.getGeometry()) {\r\n          lineStyles = styleArray.filter(function (style) {\r\n            const geometry = style.getGeometryFunction()(feature);\r\n            if (geometry) {\r\n              const type = geometry.getType();\r\n              if (type === 'GeometryCollection') {\r\n                return /** @type {GeometryCollection} */ (geometry)\r\n                  .getGeometriesArrayRecursive()\r\n                  .filter(function (geometry) {\r\n                    const type = geometry.getType();\r\n                    return type === 'LineString' || type === 'MultiLineString';\r\n                  }).length;\r\n              }\r\n              return type === 'LineString' || type === 'MultiLineString';\r\n            }\r\n          });\r\n          polyStyles = styleArray.filter(function (style) {\r\n            const geometry = style.getGeometryFunction()(feature);\r\n            if (geometry) {\r\n              const type = geometry.getType();\r\n              if (type === 'GeometryCollection') {\r\n                return /** @type {GeometryCollection} */ (geometry)\r\n                  .getGeometriesArrayRecursive()\r\n                  .filter(function (geometry) {\r\n                    const type = geometry.getType();\r\n                    return type === 'Polygon' || type === 'MultiPolygon';\r\n                  }).length;\r\n              }\r\n              return type === 'Polygon' || type === 'MultiPolygon';\r\n            }\r\n          });\r\n        }\r\n        properties['Style'] = {\r\n          pointStyles: pointStyles,\r\n          lineStyles: lineStyles,\r\n          polyStyles: polyStyles,\r\n        };\r\n      }\r\n      if (pointStyles.length && properties['name'] === undefined) {\r\n        const textStyle = pointStyles[0].getText();\r\n        if (textStyle) {\r\n          properties['name'] = textStyle.getText();\r\n        }\r\n      }\r\n    }\r\n  }\r\n  const parentNode = objectStack[objectStack.length - 1].node;\r\n  const orderedKeys = PLACEMARK_SEQUENCE[parentNode.namespaceURI];\r\n  const values = makeSequence(properties, orderedKeys);\r\n  pushSerializeAndPop(\r\n    context,\r\n    PLACEMARK_SERIALIZERS,\r\n    OBJECT_PROPERTY_NODE_FACTORY,\r\n    values,\r\n    objectStack,\r\n    orderedKeys\r\n  );\r\n\r\n  if (keys.length > 0) {\r\n    const sequence = makeSequence(properties, keys);\r\n    const namesAndValues = {names: keys, values: sequence};\r\n    pushSerializeAndPop(\r\n      context,\r\n      PLACEMARK_SERIALIZERS,\r\n      EXTENDEDDATA_NODE_FACTORY,\r\n      [namesAndValues],\r\n      objectStack\r\n    );\r\n  }\r\n\r\n  // serialize geometry\r\n  const options = /** @type {import(\"./Feature.js\").WriteOptions} */ (\r\n    objectStack[0]\r\n  );\r\n  let geometry = feature.getGeometry();\r\n  if (geometry) {\r\n    geometry = transformGeometryWithOptions(geometry, true, options);\r\n  }\r\n  pushSerializeAndPop(\r\n    context,\r\n    PLACEMARK_SERIALIZERS,\r\n    GEOMETRY_NODE_FACTORY,\r\n    [geometry],\r\n    objectStack\r\n  );\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Array<string>>}\r\n */\r\n// @ts-ignore\r\nconst PRIMITIVE_GEOMETRY_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\r\n  'extrude',\r\n  'tessellate',\r\n  'altitudeMode',\r\n  'coordinates',\r\n]);\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\n// @ts-ignore\r\nconst PRIMITIVE_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'extrude': makeChildAppender(writeBooleanTextNode),\r\n  'tessellate': makeChildAppender(writeBooleanTextNode),\r\n  'altitudeMode': makeChildAppender(writeStringTextNode),\r\n  'coordinates': makeChildAppender(writeCoordinatesTextNode),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction writePrimitiveGeometry(node, geometry, objectStack) {\r\n  const flatCoordinates = geometry.getFlatCoordinates();\r\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\r\n  context['layout'] = geometry.getLayout();\r\n  context['stride'] = geometry.getStride();\r\n\r\n  // serialize properties (properties unknown to KML are not serialized)\r\n  const properties = geometry.getProperties();\r\n  properties.coordinates = flatCoordinates;\r\n\r\n  const parentNode = objectStack[objectStack.length - 1].node;\r\n  const orderedKeys = PRIMITIVE_GEOMETRY_SEQUENCE[parentNode.namespaceURI];\r\n  const values = makeSequence(properties, orderedKeys);\r\n  pushSerializeAndPop(\r\n    context,\r\n    PRIMITIVE_GEOMETRY_SERIALIZERS,\r\n    OBJECT_PROPERTY_NODE_FACTORY,\r\n    values,\r\n    objectStack,\r\n    orderedKeys\r\n  );\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Array<string>>}\r\n */\r\n// @ts-ignore\r\nconst POLY_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\r\n  'color',\r\n  'fill',\r\n  'outline',\r\n]);\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\n// @ts-ignore\r\nconst POLYGON_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'outerBoundaryIs': makeChildAppender(writeBoundaryIs),\r\n  'innerBoundaryIs': makeChildAppender(writeBoundaryIs),\r\n});\r\n\r\n/**\r\n * A factory for creating innerBoundaryIs nodes.\r\n * @const\r\n * @type {function(*, Array<*>, string=): (Node|undefined)}\r\n */\r\nconst INNER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory('innerBoundaryIs');\r\n\r\n/**\r\n * A factory for creating outerBoundaryIs nodes.\r\n * @const\r\n * @type {function(*, Array<*>, string=): (Node|undefined)}\r\n */\r\nconst OUTER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory('outerBoundaryIs');\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Polygon} polygon Polygon.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction writePolygon(node, polygon, objectStack) {\r\n  const linearRings = polygon.getLinearRings();\r\n  const outerRing = linearRings.shift();\r\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\r\n  // inner rings\r\n  pushSerializeAndPop(\r\n    context,\r\n    POLYGON_SERIALIZERS,\r\n    INNER_BOUNDARY_NODE_FACTORY,\r\n    linearRings,\r\n    objectStack\r\n  );\r\n  // outer ring\r\n  pushSerializeAndPop(\r\n    context,\r\n    POLYGON_SERIALIZERS,\r\n    OUTER_BOUNDARY_NODE_FACTORY,\r\n    [outerRing],\r\n    objectStack\r\n  );\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\n// @ts-ignore\r\nconst POLY_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'color': makeChildAppender(writeColorTextNode),\r\n  'fill': makeChildAppender(writeBooleanTextNode),\r\n  'outline': makeChildAppender(writeBooleanTextNode),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Style} style Style.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction writePolyStyle(node, style, objectStack) {\r\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\r\n  const fill = style.getFill();\r\n  const stroke = style.getStroke();\r\n  const properties = {\r\n    'color': fill ? fill.getColor() : undefined,\r\n    'fill': fill ? undefined : false,\r\n    'outline': stroke ? undefined : false,\r\n  };\r\n  const parentNode = objectStack[objectStack.length - 1].node;\r\n  const orderedKeys = POLY_STYLE_SEQUENCE[parentNode.namespaceURI];\r\n  const values = makeSequence(properties, orderedKeys);\r\n  pushSerializeAndPop(\r\n    context,\r\n    POLY_STYLE_SERIALIZERS,\r\n    OBJECT_PROPERTY_NODE_FACTORY,\r\n    values,\r\n    objectStack,\r\n    orderedKeys\r\n  );\r\n}\r\n\r\n/**\r\n * @param {Node} node Node to append a TextNode with the scale to.\r\n * @param {number|undefined} scale Scale.\r\n */\r\nfunction writeScaleTextNode(node, scale) {\r\n  // the Math is to remove any excess decimals created by float arithmetic\r\n  writeDecimalTextNode(node, Math.round(scale * 1e6) / 1e6);\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Array<string>>}\r\n */\r\n// @ts-ignore\r\nconst STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\r\n  'IconStyle',\r\n  'LabelStyle',\r\n  'LineStyle',\r\n  'PolyStyle',\r\n]);\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\n// @ts-ignore\r\nconst STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'IconStyle': makeChildAppender(writeIconStyle),\r\n  'LabelStyle': makeChildAppender(writeLabelStyle),\r\n  'LineStyle': makeChildAppender(writeLineStyle),\r\n  'PolyStyle': makeChildAppender(writePolyStyle),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Object<string, Array<Style>>} styles Styles.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction writeStyle(node, styles, objectStack) {\r\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\r\n  const properties = {};\r\n  if (styles.pointStyles.length) {\r\n    const textStyle = styles.pointStyles[0].getText();\r\n    if (textStyle) {\r\n      properties['LabelStyle'] = textStyle;\r\n    }\r\n    const imageStyle = styles.pointStyles[0].getImage();\r\n    if (\r\n      imageStyle &&\r\n      typeof (/** @type {?} */ (imageStyle).getSrc) === 'function'\r\n    ) {\r\n      properties['IconStyle'] = imageStyle;\r\n    }\r\n  }\r\n  if (styles.lineStyles.length) {\r\n    const strokeStyle = styles.lineStyles[0].getStroke();\r\n    if (strokeStyle) {\r\n      properties['LineStyle'] = strokeStyle;\r\n    }\r\n  }\r\n  if (styles.polyStyles.length) {\r\n    const strokeStyle = styles.polyStyles[0].getStroke();\r\n    if (strokeStyle && !properties['LineStyle']) {\r\n      properties['LineStyle'] = strokeStyle;\r\n    }\r\n    properties['PolyStyle'] = styles.polyStyles[0];\r\n  }\r\n  const parentNode = objectStack[objectStack.length - 1].node;\r\n  const orderedKeys = STYLE_SEQUENCE[parentNode.namespaceURI];\r\n  const values = makeSequence(properties, orderedKeys);\r\n  pushSerializeAndPop(\r\n    context,\r\n    STYLE_SERIALIZERS,\r\n    OBJECT_PROPERTY_NODE_FACTORY,\r\n    values,\r\n    objectStack,\r\n    orderedKeys\r\n  );\r\n}\r\n\r\n/**\r\n * @param {Element} node Node to append a TextNode with the Vec2 to.\r\n * @param {Vec2} vec2 Vec2.\r\n */\r\nfunction writeVec2(node, vec2) {\r\n  node.setAttribute('x', String(vec2.x));\r\n  node.setAttribute('y', String(vec2.y));\r\n  node.setAttribute('xunits', vec2.xunits);\r\n  node.setAttribute('yunits', vec2.yunits);\r\n}\r\n\r\nexport default KML;\r\n", "import d from \"./node_modules/ol/format/KML.js\";export default d;\nexport * from \"./node_modules/ol/format/KML.js\""],
  "mappings": "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",
  "names": ["Feature_default", "geometry", "imageState", "imageSize", "type"]
}
